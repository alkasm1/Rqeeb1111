<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>كاشف المستندات المزورة - تحليل ذكي متقدم</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/4b9ba14b0f.js" crossorigin="anonymous"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE'
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .upload-area {
            border: 2px dashed #d1d5db;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #5D5CDE;
            background-color: rgba(93, 92, 222, 0.05);
        }
        .upload-area.dragover {
            border-color: #5D5CDE;
            background-color: rgba(93, 92, 222, 0.1);
        }
        .analysis-card {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%);
            border: 1px solid rgba(93, 92, 222, 0.2);
            transition: all 0.3s ease;
        }
        .analysis-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(93, 92, 222, 0.15);
        }
        .progress-container {
            background: linear-gradient(90deg, #5D5CDE 0%, #9333EA 100%);
        }
        .result-excellent { background: linear-gradient(135deg, #10B981 0%, #059669 100%); }
        .result-good { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); }
        .result-poor { background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); }
        .metric-card {
            transition: all 0.3s ease;
            border: 1px solid rgba(93, 92, 222, 0.1);
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(93, 92, 222, 0.15);
        }
        .region-selector {
            position: relative;
            display: inline-block;
        }
        .region-overlay {
            position: absolute;
            border: 2px solid #5D5CDE;
            background: rgba(93, 92, 222, 0.2);
            pointer-events: none;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        .image-preview {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        .image-preview img {
            width: 100%;
            height: auto;
            display: block;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
        }
        .detection-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
        }
        .badge-currency { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); }
        .badge-document { background: linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%); }
        .badge-mixed { background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-primary to-purple-600 bg-clip-text text-transparent">
                <i class="fas fa-shield-alt mr-3"></i>
                كاشف المستندات المزورة - نظام ذكي متقدم
            </h1>
            <p class="text-gray-600 dark:text-gray-400 text-lg">
                تحليل متطور للكشف عن التزوير مع تمييز ذكي بين العملات والمستندات واختيار المناطق الهندسية المثلى
            </p>
        </div>

        <!-- Document Type Detection -->
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 flex items-center">
                <i class="fas fa-cogs mr-3 text-primary"></i>
                إعدادات التحليل الذكي
            </h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div class="analysis-card p-4 rounded-lg">
                    <label class="flex items-center space-x-3 cursor-pointer">
                        <input type="radio" name="docType" value="auto" checked class="text-primary">
                        <div>
                            <i class="fas fa-magic text-primary mr-2"></i>
                            <span class="font-medium">كشف تلقائي</span>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">النظام سيحدد نوع المستند تلقائياً</p>
                        </div>
                    </label>
                </div>
                
                <div class="analysis-card p-4 rounded-lg">
                    <label class="flex items-center space-x-3 cursor-pointer">
                        <input type="radio" name="docType" value="currency" class="text-primary">
                        <div>
                            <i class="fas fa-coins text-primary mr-2"></i>
                            <span class="font-medium">عملة ورقية</span>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">تحليل متخصص للعملات الورقية</p>
                        </div>
                    </label>
                </div>
                
                <div class="analysis-card p-4 rounded-lg">
                    <label class="flex items-center space-x-3 cursor-pointer">
                        <input type="radio" name="docType" value="document" class="text-primary">
                        <div>
                            <i class="fas fa-file-alt text-primary mr-2"></i>
                            <span class="font-medium">وثيقة رسمية</span>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">تحليل متخصص للمستندات الرسمية</p>
                        </div>
                    </label>
                </div>
            </div>
            
            <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border border-blue-200 dark:border-blue-700">
                <h4 class="font-bold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                    <i class="fas fa-lightbulb mr-2"></i>
                    خوارزميات التحليل الذكي
                </h4>
                <ul class="text-blue-700 dark:text-blue-300 text-sm space-y-1">
                    <li>• <strong>العملات:</strong> كشف العلامات المائية، الحبر المغناطيسي، والأنماط الأمنية</li>
                    <li>• <strong>المستندات:</strong> تحليل الأختام، التوقيعات، وجودة الطباعة</li>
                    <li>• <strong>التلقائي:</strong> تحديد نوع المستند وتطبيق الخوارزمية المناسبة</li>
                </ul>
            </div>
        </div>

        <!-- Upload Section -->
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 flex items-center">
                <i class="fas fa-upload mr-3 text-primary"></i>
                رفع الصورة للتحليل المتقدم
            </h2>
            
            <div id="uploadArea" class="upload-area rounded-lg p-8 text-center cursor-pointer bg-gray-50 dark:bg-gray-700">
                <div id="uploadContent">
                    <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
                    <p class="text-lg font-medium text-gray-600 dark:text-gray-300 mb-2">
                        اسحب الصورة هنا أو انقر للاختيار
                    </p>
                    <p class="text-sm text-gray-500 dark:text-gray-400">
                        يدعم: JPG, PNG, GIF (حتى 10 ميجابايت)
                    </p>
                    <input type="file" id="imageFile" accept="image/*" class="hidden">
                </div>
                <div id="imagePreview" class="hidden">
                    <div class="region-selector">
                        <img id="previewImg" class="max-w-full h-64 object-contain mx-auto rounded-lg">
                        <div id="detectedType" class="detection-badge hidden"></div>
                    </div>
                    <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">الصورة جاهزة للتحليل</p>
                </div>
            </div>

            <button id="analyzeBtn" class="w-full mt-4 bg-gradient-to-r from-primary to-purple-600 text-white font-bold py-3 px-6 rounded-lg hover:shadow-lg transform hover:scale-105 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i class="fas fa-search mr-2"></i>
                بدء التحليل الذكي المتقدم
            </button>
        </div>

        <!-- Progress Section -->
        <div id="progressSection" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
            <h3 class="text-xl font-bold mb-4 flex items-center">
                <i class="fas fa-cog fa-spin mr-3 text-primary"></i>
                جاري التحليل الذكي...
            </h3>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4 mb-4">
                <div id="progressBar" class="progress-container h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
            </div>
            <p id="progressText" class="text-center text-gray-600 dark:text-gray-400 font-medium">0% - جاري التحضير...</p>
            
            <div id="analysisSteps" class="mt-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div id="step1" class="analysis-card p-3 rounded-lg opacity-50">
                    <i class="fas fa-search text-primary mr-2"></i>
                    <span class="text-sm">كشف النوع</span>
                </div>
                <div id="step2" class="analysis-card p-3 rounded-lg opacity-50">
                    <i class="fas fa-crop text-primary mr-2"></i>
                    <span class="text-sm">اختيار المناطق</span>
                </div>
                <div id="step3" class="analysis-card p-3 rounded-lg opacity-50">
                    <i class="fas fa-calculator text-primary mr-2"></i>
                    <span class="text-sm">التحليل المتقدم</span>
                </div>
                <div id="step4" class="analysis-card p-3 rounded-lg opacity-50">
                    <i class="fas fa-chart-bar text-primary mr-2"></i>
                    <span class="text-sm">النتائج</span>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultSection" class="hidden">
            <!-- Document Type Detection Result -->
            <div id="documentTypeResult" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-4 flex items-center">
                    <i class="fas fa-brain mr-3 text-primary"></i>
                    نتائج الكشف الذكي
                </h2>
                <div id="typeDetectionDisplay">
                    <!-- Type detection results will be inserted here -->
                </div>
            </div>

            <!-- Overall Score -->
            <div id="overallScore" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-4 flex items-center">
                    <i class="fas fa-chart-line mr-3 text-primary"></i>
                    النتيجة الإجمالية - التحليل المتقدم
                </h2>
                <div id="scoreDisplay" class="text-center p-6 rounded-lg text-white font-bold text-3xl">
                    <!-- Score will be inserted here -->
                </div>
                <div id="scoreInterpretation" class="mt-4 p-4 rounded-lg">
                    <!-- Interpretation will be inserted here -->
                </div>
            </div>

            <!-- Detailed Analysis -->
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-6 flex items-center">
                    <i class="fas fa-microscope mr-3 text-primary"></i>
                    تحليل مفصل للمقاييس المتقدمة
                </h2>
                <div id="detailedMetrics" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Metrics will be inserted here -->
                </div>
            </div>

            <!-- Smart Region Analysis -->
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-6 flex items-center">
                    <i class="fas fa-puzzle-piece mr-3 text-primary"></i>
                    تحليل المناطق الذكية
                </h2>
                <div id="regionAnalysis">
                    <!-- Region analysis will be inserted here -->
                </div>
            </div>

            <!-- Visual Comparison -->
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6">
                <h2 class="text-2xl font-bold mb-6 flex items-center">
                    <i class="fas fa-eye mr-3 text-primary"></i>
                    المقارنة البصرية والفروقات المتقدمة
                </h2>
                <div id="visualComparison">
                    <!-- Visual comparison will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Dark mode handling
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Global variables for advanced analysis
        let currentDocumentType = 'auto';
        let detectedRegions = [];
        let analysisResults = {};

        // Upload handling
        const uploadArea = document.getElementById('uploadArea');
        const imageFile = document.getElementById('imageFile');
        const uploadContent = document.getElementById('uploadContent');
        const imagePreview = document.getElementById('imagePreview');
        const previewImg = document.getElementById('previewImg');
        const analyzeBtn = document.getElementById('analyzeBtn');

        // Document type selection
        document.querySelectorAll('input[name="docType"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                currentDocumentType = e.target.value;
                console.log('Document type selected:', currentDocumentType);
            });
        });

        uploadArea.addEventListener('click', () => imageFile.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        imageFile.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        function handleFileSelect(file) {
            if (!file.type.startsWith('image/')) {
                showCustomAlert('يرجى اختيار ملف صورة صحيح');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                showCustomAlert('حجم الملف كبير جداً (حد أقصى 10 ميجابايت)');
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                previewImg.src = e.target.result;
                uploadContent.classList.add('hidden');
                imagePreview.classList.remove('hidden');
                analyzeBtn.disabled = false;

                // Perform quick document type detection
                if (currentDocumentType === 'auto') {
                    const detectedType = await detectDocumentType(e.target.result);
                    displayDetectedType(detectedType);
                }
            };
            reader.readAsDataURL(file);
        }

        analyzeBtn.addEventListener('click', startAdvancedAnalysis);

        async function detectDocumentType(imageDataURL) {
            // Advanced document type detection algorithm
            try {
                const canvas = await loadImageFromDataURL(imageDataURL);
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Analyze image characteristics
                const features = extractImageFeatures(imageData);
                
                // Decision algorithm based on features
                let currencyScore = 0;
                let documentScore = 0;
                
                // Check for currency characteristics
                if (features.hasComplexPatterns) currencyScore += 30;
                if (features.hasWatermarkRegions) currencyScore += 25;
                if (features.colorVariety > 0.7) currencyScore += 20;
                if (features.hasSecurityFeatures) currencyScore += 25;
                
                // Check for document characteristics
                if (features.hasTextRegions) documentScore += 30;
                if (features.hasStampLikeFeatures) documentScore += 25;
                if (features.colorVariety < 0.4) documentScore += 20;
                if (features.hasRectangularStructure) documentScore += 25;
                
                console.log('Detection scores - Currency:', currencyScore, 'Document:', documentScore);
                
                if (currencyScore > documentScore && currencyScore > 50) {
                    return { type: 'currency', confidence: currencyScore };
                } else if (documentScore > 50) {
                    return { type: 'document', confidence: documentScore };
                } else {
                    return { type: 'mixed', confidence: Math.max(currencyScore, documentScore) };
                }
                
            } catch (error) {
                console.error('Error in document type detection:', error);
                return { type: 'unknown', confidence: 0 };
            }
        }

        function extractImageFeatures(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            let colorVariety = 0;
            let textRegions = 0;
            let complexPatterns = 0;
            let watermarkRegions = 0;
            let rectangularStructure = 0;
            let securityFeatures = 0;
            let stampFeatures = 0;
            
            // Color analysis
            const colorHistogram = new Map();
            for (let i = 0; i < data.length; i += 4) {
                const color = `${data[i]}-${data[i+1]}-${data[i+2]}`;
                colorHistogram.set(color, (colorHistogram.get(color) || 0) + 1);
            }
            colorVariety = colorHistogram.size / (width * height);
            
            // Pattern and texture analysis
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Edge detection for text regions
                    const gx = Math.abs(data[idx + 4] - data[idx - 4]);
                    const gy = Math.abs(data[idx + width * 4] - data[idx - width * 4]);
                    const gradient = Math.sqrt(gx * gx + gy * gy);
                    
                    if (gradient > 50) textRegions++;
                    if (gradient > 100) complexPatterns++;
                    
                    // Security features detection (high frequency patterns)
                    if (gradient > 150) securityFeatures++;
                    
                    // Watermark detection (subtle patterns)
                    if (gradient > 20 && gradient < 40) watermarkRegions++;
                }
            }
            
            // Rectangular structure detection
            rectangularStructure = detectRectangularStructure(imageData);
            
            // Stamp-like features detection
            stampFeatures = detectStampFeatures(imageData);
            
            return {
                colorVariety: Math.min(1, colorVariety * 100),
                hasTextRegions: textRegions > (width * height * 0.1),
                hasComplexPatterns: complexPatterns > (width * height * 0.05),
                hasWatermarkRegions: watermarkRegions > (width * height * 0.02),
                hasRectangularStructure: rectangularStructure > 0.3,
                hasSecurityFeatures: securityFeatures > (width * height * 0.01),
                hasStampLikeFeatures: stampFeatures > 0.2
            };
        }

        function detectRectangularStructure(imageData) {
            // Simplified rectangular structure detection
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            let horizontalLines = 0;
            let verticalLines = 0;
            
            // Check for horizontal lines
            for (let y = 0; y < height; y += 5) {
                let lineStrength = 0;
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    const prevGray = (data[idx - 4] + data[idx - 3] + data[idx - 2]) / 3;
                    if (Math.abs(gray - prevGray) > 30) lineStrength++;
                }
                if (lineStrength > width * 0.7) horizontalLines++;
            }
            
            // Check for vertical lines
            for (let x = 0; x < width; x += 5) {
                let lineStrength = 0;
                for (let y = 1; y < height - 1; y++) {
                    const idx = (y * width + x) * 4;
                    const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    const prevGray = (data[(y-1) * width + x] * 4);
                    const prevGrayVal = (data[prevGray] + data[prevGray + 1] + data[prevGray + 2]) / 3;
                    if (Math.abs(gray - prevGrayVal) > 30) lineStrength++;
                }
                if (lineStrength > height * 0.7) verticalLines++;
            }
            
            return (horizontalLines + verticalLines) / Math.max(width + height, 1);
        }

        function detectStampFeatures(imageData) {
            // Simplified stamp detection (circular/oval patterns)
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            let circularPatterns = 0;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Check for circular patterns around center
            for (let radius = 20; radius < Math.min(width, height) / 4; radius += 10) {
                let circleStrength = 0;
                let points = 0;
                
                for (let angle = 0; angle < 360; angle += 10) {
                    const x = Math.round(centerX + radius * Math.cos(angle * Math.PI / 180));
                    const y = Math.round(centerY + radius * Math.sin(angle * Math.PI / 180));
                    
                    if (x >= 0 && x < width && y >= 0 && y < height) {
                        const idx = (y * width + x) * 4;
                        const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        
                        // Check for edge-like features
                        if (gray < 100 || gray > 200) circleStrength++;
                        points++;
                    }
                }
                
                if (points > 0 && (circleStrength / points) > 0.3) {
                    circularPatterns++;
                }
            }
            
            return circularPatterns / 10; // Normalize
        }

        function displayDetectedType(detection) {
            const badge = document.getElementById('detectedType');
            const { type, confidence } = detection;
            
            let badgeClass, icon, text;
            
            switch (type) {
                case 'currency':
                    badgeClass = 'badge-currency';
                    icon = 'fas fa-coins';
                    text = `عملة ورقية (${confidence}%)`;
                    break;
                case 'document':
                    badgeClass = 'badge-document';
                    icon = 'fas fa-file-alt';
                    text = `وثيقة رسمية (${confidence}%)`;
                    break;
                case 'mixed':
                    badgeClass = 'badge-mixed';
                    icon = 'fas fa-question';
                    text = `مختلط (${confidence}%)`;
                    break;
                default:
                    badgeClass = 'badge-mixed';
                    icon = 'fas fa-exclamation';
                    text = 'غير محدد';
            }
            
            badge.className = `detection-badge ${badgeClass}`;
            badge.innerHTML = `<i class="${icon} mr-1"></i>${text}`;
            badge.classList.remove('hidden');
            
            // Update current document type if auto-detection
            if (currentDocumentType === 'auto') {
                currentDocumentType = type;
            }
        }

        async function startAdvancedAnalysis() {
            const file = imageFile.files[0];
            if (!file) {
                showCustomAlert('يرجى اختيار صورة أولاً');
                return;
            }

            // Show progress section
            document.getElementById('progressSection').classList.remove('hidden');
            document.getElementById('resultSection').classList.add('hidden');
            
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');

            try {
                // Step 1: Document type detection
                activateStep(1);
                updateProgress(5, 'كشف نوع المستند...');
                const imageCanvas = await loadImageToCanvas(file);
                
                let finalDocType = currentDocumentType;
                if (currentDocumentType === 'auto') {
                    const detection = await detectDocumentType(previewImg.src);
                    finalDocType = detection.type;
                    updateProgress(10, `تم كشف النوع: ${getDocTypeArabic(finalDocType)}`);
                } else {
                    updateProgress(10, `النوع المحدد: ${getDocTypeArabic(finalDocType)}`);
                }

                // Step 2: Smart region selection
                activateStep(2);
                updateProgress(15, 'اختيار المناطق الذكية للمقارنة...');
                const smartRegions = await selectSmartRegions(imageCanvas, finalDocType);
                updateProgress(25, `تم اختيار ${smartRegions.length} منطقة للتحليل`);

                // Step 3: Advanced analysis
                activateStep(3);
                updateProgress(30, 'بدء التحليل المتقدم...');
                
                const analysisPromises = [];
                
                // Perform different analyses based on document type
                if (finalDocType === 'currency') {
                    analysisPromises.push(analyzeCurrencyFeatures(smartRegions));
                } else if (finalDocType === 'document') {
                    analysisPromises.push(analyzeDocumentFeatures(smartRegions));
                } else {
                    analysisPromises.push(analyzeGeneralFeatures(smartRegions));
                }

                updateProgress(40, 'تحليل الملمس والأنماط المتقدم...');
                const advancedTextureScore = await analyzeAdvancedTexture(smartRegions);

                updateProgress(50, 'تحليل التردد والطيف اللوني...');
                const advancedFreqScore = await analyzeAdvancedFrequency(smartRegions);

                updateProgress(60, 'تحليل توزيع الألوان والتدرجات...');
                const advancedColorScore = await analyzeAdvancedColor(smartRegions);

                updateProgress(70, 'كشف التلاعب والتزوير المتقدم...');
                const forgeryScore = await detectAdvancedForgery(smartRegions, finalDocType);

                updateProgress(80, 'تحليل الهندسة والتماثل...');
                const geometryScore = await analyzeGeometry(smartRegions);

                updateProgress(85, 'كشف العلامات المائية والميزات الأمنية...');
                const securityScore = await analyzeSecurityFeatures(smartRegions, finalDocType);

                updateProgress(90, 'إنشاء الصور المقارنة والخرائط الحرارية...');
                const visualResults = await createAdvancedVisualResults(smartRegions);

                // Step 4: Calculate final score
                activateStep(4);
                updateProgress(95, 'حساب النتيجة النهائية...');

                const weights = getAnalysisWeights(finalDocType);
                const finalScore = calculateWeightedScore({
                    texture: advancedTextureScore,
                    frequency: advancedFreqScore,
                    color: advancedColorScore,
                    forgery: forgeryScore,
                    geometry: geometryScore,
                    security: securityScore
                }, weights);

                updateProgress(100, `تم الانتهاء - النتيجة النهائية: ${finalScore.toFixed(1)}%`);

                // Store results
                analysisResults = {
                    documentType: finalDocType,
                    score: finalScore,
                    regions: smartRegions,
                    metrics: {
                        texture: advancedTextureScore,
                        frequency: advancedFreqScore,
                        color: advancedColorScore,
                        forgery: forgeryScore,
                        geometry: geometryScore,
                        security: securityScore
                    },
                    visual: visualResults,
                    weights: weights
                };

                // Display results
                setTimeout(() => {
                    displayAdvancedResults(analysisResults);
                }, 1000);

            } catch (error) {
                console.error('Error during advanced analysis:', error);
                showCustomAlert('حدث خطأ أثناء التحليل المتقدم: ' + error.message);
            }
        }

        function activateStep(stepNumber) {
            const step = document.getElementById(`step${stepNumber}`);
            if (step) {
                step.classList.remove('opacity-50');
                step.classList.add('bg-primary', 'text-white');
            }
        }

        function getDocTypeArabic(type) {
            const types = {
                'currency': 'عملة ورقية',
                'document': 'وثيقة رسمية',
                'mixed': 'مختلط',
                'auto': 'تلقائي'
            };
            return types[type] || 'غير محدد';
        }

        async function selectSmartRegions(canvas, docType) {
            // Advanced region selection algorithm
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            let regions = [];
            
            if (docType === 'currency') {
                regions = selectCurrencyRegions(canvas, imageData);
            } else if (docType === 'document') {
                regions = selectDocumentRegions(canvas, imageData);
            } else {
                regions = selectGeneralRegions(canvas, imageData);
            }
            
            return regions;
        }

        function selectCurrencyRegions(canvas, imageData) {
            // Select regions based on currency-specific features
            const regions = [];
            const width = canvas.width;
            const height = canvas.height;
            
            // Central region (often contains main design)
            const centerRegion = extractRegion(canvas, 
                width * 0.25, height * 0.25, 
                width * 0.5, height * 0.5);
            regions.push({ canvas: centerRegion, type: 'center', weight: 0.4 });
            
            // Corner regions (security features)
            const cornerSize = Math.min(width, height) * 0.2;
            regions.push({ 
                canvas: extractRegion(canvas, 0, 0, cornerSize, cornerSize), 
                type: 'corner_tl', weight: 0.15 
            });
            regions.push({ 
                canvas: extractRegion(canvas, width - cornerSize, 0, cornerSize, cornerSize), 
                type: 'corner_tr', weight: 0.15 
            });
            
            // Edge regions (borders and patterns)
            regions.push({ 
                canvas: extractRegion(canvas, 0, height * 0.4, width * 0.1, height * 0.2), 
                type: 'edge_left', weight: 0.15 
            });
            regions.push({ 
                canvas: extractRegion(canvas, width * 0.9, height * 0.4, width * 0.1, height * 0.2), 
                type: 'edge_right', weight: 0.15 
            });
            
            return regions;
        }

        function selectDocumentRegions(canvas, imageData) {
            // Select regions based on document-specific features
            const regions = [];
            const width = canvas.width;
            const height = canvas.height;
            
            // Header region (titles, logos)
            regions.push({ 
                canvas: extractRegion(canvas, 0, 0, width, height * 0.25), 
                type: 'header', weight: 0.3 
            });
            
            // Main content area
            regions.push({ 
                canvas: extractRegion(canvas, width * 0.1, height * 0.3, width * 0.8, height * 0.4), 
                type: 'content', weight: 0.25 
            });
            
            // Signature/Stamp area
            regions.push({ 
                canvas: extractRegion(canvas, width * 0.6, height * 0.75, width * 0.35, height * 0.2), 
                type: 'signature', weight: 0.25 
            });
            
            // Watermark area (if present)
            regions.push({ 
                canvas: extractRegion(canvas, width * 0.2, height * 0.2, width * 0.6, height * 0.6), 
                type: 'watermark', weight: 0.2 
            });
            
            return regions;
        }

        function selectGeneralRegions(canvas, imageData) {
            // General region selection for mixed or unknown documents
            const regions = [];
            const width = canvas.width;
            const height = canvas.height;
            
            // Divide into grid regions
            const gridSize = 3;
            const regionWidth = width / gridSize;
            const regionHeight = height / gridSize;
            
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const x = col * regionWidth;
                    const y = row * regionHeight;
                    
                    regions.push({
                        canvas: extractRegion(canvas, x, y, regionWidth, regionHeight),
                        type: `grid_${row}_${col}`,
                        weight: row === 1 && col === 1 ? 0.2 : 0.1 // Center region gets higher weight
                    });
                }
            }
            
            return regions;
        }

        function extractRegion(sourceCanvas, x, y, width, height) {
            const regionCanvas = document.createElement('canvas');
            regionCanvas.width = width;
            regionCanvas.height = height;
            const ctx = regionCanvas.getContext('2d');
            
            ctx.drawImage(sourceCanvas, x, y, width, height, 0, 0, width, height);
            return regionCanvas;
        }

        async function analyzeAdvancedTexture(regions) {
            // Advanced texture analysis using multiple algorithms
            let totalScore = 0;
            let totalWeight = 0;
            
            for (const region of regions) {
                const canvas = region.canvas;
                const grayCanvas = convertToGrayscale(canvas);
                
                // Local Binary Pattern analysis
                const lbpScore = analyzeLBP(grayCanvas);
                
                // Gabor filter analysis
                const gaborScore = analyzeGabor(grayCanvas);
                
                // Co-occurrence matrix analysis
                const glcmScore = analyzeGLCM(grayCanvas);
                
                // Combine scores
                const regionScore = (lbpScore + gaborScore + glcmScore) / 3;
                totalScore += regionScore * region.weight;
                totalWeight += region.weight;
            }
            
            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        function analyzeLBP(canvas) {
            // Local Binary Pattern analysis
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let lbpHistogram = new Array(256).fill(0);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const centerIdx = (y * width + x) * 4;
                    const centerVal = data[centerIdx];
                    
                    let lbpValue = 0;
                    let power = 1;
                    
                    // Check 8 neighbors
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const neighborIdx = ((y + dy) * width + (x + dx)) * 4;
                            const neighborVal = data[neighborIdx];
                            
                            if (neighborVal >= centerVal) {
                                lbpValue += power;
                            }
                            power *= 2;
                        }
                    }
                    
                    lbpHistogram[lbpValue]++;
                }
            }
            
            // Calculate uniformity measure
            let uniformity = 0;
            const totalPixels = (width - 2) * (height - 2);
            
            for (let i = 0; i < 256; i++) {
                const probability = lbpHistogram[i] / totalPixels;
                if (probability > 0) {
                    uniformity += probability * probability;
                }
            }
            
            return Math.min(100, uniformity * 1000); // Scale to 0-100
        }

        function analyzeGabor(canvas) {
            // Simplified Gabor filter analysis
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let totalEnergy = 0;
            let pixelCount = 0;
            
            // Apply multiple Gabor-like filters
            const frequencies = [0.1, 0.2, 0.3];
            const orientations = [0, 45, 90, 135];
            
            for (const freq of frequencies) {
                for (const orient of orientations) {
                    let filterResponse = 0;
                    
                    for (let y = 2; y < height - 2; y++) {
                        for (let x = 2; x < width - 2; x++) {
                            const idx = (y * width + x) * 4;
                            const intensity = data[idx];
                            
                            // Simplified Gabor-like calculation
                            const angle = Math.atan2(y - height/2, x - width/2) * 180 / Math.PI;
                            const distance = Math.sqrt((x - width/2)**2 + (y - height/2)**2);
                            
                            const gaborValue = intensity * Math.cos(2 * Math.PI * freq * distance) * 
                                             Math.exp(-((angle - orient)**2) / (2 * 30**2));
                            
                            filterResponse += Math.abs(gaborValue);
                            pixelCount++;
                        }
                    }
                    
                    totalEnergy += filterResponse;
                }
            }
            
            const avgEnergy = pixelCount > 0 ? totalEnergy / pixelCount : 0;
            return Math.min(100, avgEnergy / 10); // Scale to 0-100
        }

        function analyzeGLCM(canvas) {
            // Gray Level Co-occurrence Matrix analysis
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Build co-occurrence matrix (simplified)
            const glcm = new Array(256).fill(null).map(() => new Array(256).fill(0));
            let totalPairs = 0;
            
            for (let y = 0; y < height - 1; y++) {
                for (let x = 0; x < width - 1; x++) {
                    const idx1 = (y * width + x) * 4;
                    const idx2 = (y * width + (x + 1)) * 4;
                    
                    const gray1 = data[idx1];
                    const gray2 = data[idx2];
                    
                    glcm[gray1][gray2]++;
                    totalPairs++;
                }
            }
            
            // Calculate texture measures
            let contrast = 0;
            let homogeneity = 0;
            let energy = 0;
            
            for (let i = 0; i < 256; i++) {
                for (let j = 0; j < 256; j++) {
                    const probability = glcm[i][j] / totalPairs;
                    
                    contrast += probability * (i - j) ** 2;
                    homogeneity += probability / (1 + Math.abs(i - j));
                    energy += probability ** 2;
                }
            }
            
            // Combine measures into a single score
            const textureScore = (homogeneity * 50) + (energy * 30) + (Math.max(0, 20 - contrast/100) * 20);
            return Math.min(100, Math.max(0, textureScore));
        }

        async function analyzeAdvancedFrequency(regions) {
            // Advanced frequency domain analysis
            let totalScore = 0;
            let totalWeight = 0;
            
            for (const region of regions) {
                const canvas = region.canvas;
                const grayCanvas = convertToGrayscale(canvas);
                
                // DCT-based frequency analysis
                const dctScore = analyzeDCT(grayCanvas);
                
                // Wavelet-like analysis
                const waveletScore = analyzeWavelet(grayCanvas);
                
                // Spectral analysis
                const spectralScore = analyzeSpectral(grayCanvas);
                
                const regionScore = (dctScore + waveletScore + spectralScore) / 3;
                totalScore += regionScore * region.weight;
                totalWeight += region.weight;
            }
            
            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        function analyzeDCT(canvas) {
            // Simplified DCT analysis
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let lowFreq = 0, midFreq = 0, highFreq = 0;
            let totalBlocks = 0;
            
            // Process 8x8 blocks
            for (let y = 0; y < height - 7; y += 8) {
                for (let x = 0; x < width - 7; x += 8) {
                    const block = extractBlock(data, x, y, width, 8);
                    const dctCoeffs = simpleDCT(block);
                    
                    // Categorize frequencies
                    for (let i = 0; i < 8; i++) {
                        for (let j = 0; j < 8; j++) {
                            const coeff = Math.abs(dctCoeffs[i][j]);
                            
                            if (i + j < 2) lowFreq += coeff;
                            else if (i + j < 5) midFreq += coeff;
                            else highFreq += coeff;
                        }
                    }
                    totalBlocks++;
                }
            }
            
            if (totalBlocks === 0) return 50;
            
            const avgLow = lowFreq / totalBlocks;
            const avgMid = midFreq / totalBlocks;
            const avgHigh = highFreq / totalBlocks;
            
            // Calculate frequency distribution score
            const total = avgLow + avgMid + avgHigh;
            if (total === 0) return 50;
            
            const lowRatio = avgLow / total;
            const midRatio = avgMid / total;
            const highRatio = avgHigh / total;
            
            // Good images have balanced frequency distribution
            const balance = 1 - Math.abs(0.33 - lowRatio) - Math.abs(0.33 - midRatio) - Math.abs(0.33 - highRatio);
            return Math.max(0, Math.min(100, balance * 100));
        }

        function extractBlock(data, startX, startY, width, blockSize) {
            const block = [];
            for (let y = 0; y < blockSize; y++) {
                block[y] = [];
                for (let x = 0; x < blockSize; x++) {
                    const idx = ((startY + y) * width + (startX + x)) * 4;
                    block[y][x] = data[idx]; // Use red channel
                }
            }
            return block;
        }

        function simpleDCT(block) {
            // Simplified 8x8 DCT
            const size = block.length;
            const dct = new Array(size).fill(null).map(() => new Array(size).fill(0));
            
            for (let u = 0; u < size; u++) {
                for (let v = 0; v < size; v++) {
                    let sum = 0;
                    
                    for (let x = 0; x < size; x++) {
                        for (let y = 0; y < size; y++) {
                            sum += block[x][y] * 
                                   Math.cos((2 * x + 1) * u * Math.PI / (2 * size)) *
                                   Math.cos((2 * y + 1) * v * Math.PI / (2 * size));
                        }
                    }
                    
                    const cu = u === 0 ? 1 / Math.sqrt(2) : 1;
                    const cv = v === 0 ? 1 / Math.sqrt(2) : 1;
                    
                    dct[u][v] = (cu * cv / 4) * sum;
                }
            }
            
            return dct;
        }

        function analyzeWavelet(canvas) {
            // Simplified wavelet analysis using Haar-like wavelets
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let horizontalEnergy = 0;
            let verticalEnergy = 0;
            let diagonalEnergy = 0;
            let approximationEnergy = 0;
            
            // Simple 2x2 Haar wavelet transform
            for (let y = 0; y < height - 1; y += 2) {
                for (let x = 0; x < width - 1; x += 2) {
                    const a = data[(y * width + x) * 4];
                    const b = data[(y * width + (x + 1)) * 4];
                    const c = data[((y + 1) * width + x) * 4];
                    const d = data[((y + 1) * width + (x + 1)) * 4];
                    
                    // Haar coefficients
                    const approx = (a + b + c + d) / 4;
                    const horizontal = (a + c - b - d) / 4;
                    const vertical = (a + b - c - d) / 4;
                    const diagonal = (a - b - c + d) / 4;
                    
                    approximationEnergy += approx * approx;
                    horizontalEnergy += horizontal * horizontal;
                    verticalEnergy += vertical * vertical;
                    diagonalEnergy += diagonal * diagonal;
                }
            }
            
            const totalEnergy = approximationEnergy + horizontalEnergy + verticalEnergy + diagonalEnergy;
            
            if (totalEnergy === 0) return 50;
            
            // Calculate energy distribution
            const approxRatio = approximationEnergy / totalEnergy;
            const detailRatio = (horizontalEnergy + verticalEnergy + diagonalEnergy) / totalEnergy;
            
            // Good balance between approximation and details
            const balance = 1 - Math.abs(0.7 - approxRatio);
            return Math.max(0, Math.min(100, balance * 100));
        }

        function analyzeSpectral(canvas) {
            // Spectral analysis using simplified FFT-like approach
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let spectralMagnitude = 0;
            let spectralPhase = 0;
            let componentCount = 0;
            
            // Analyze frequency components using gradient-based approach
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const current = data[idx];
                    
                    // Calculate gradients (approximating frequency components)
                    const gx = data[idx + 4] - data[idx - 4]; // horizontal gradient
                    const gy = data[idx + width * 4] - data[idx - width * 4]; // vertical gradient
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const phase = Math.atan2(gy, gx);
                    
                    spectralMagnitude += magnitude;
                    spectralPhase += Math.abs(phase);
                    componentCount++;
                }
            }
            
            if (componentCount === 0) return 50;
            
            const avgMagnitude = spectralMagnitude / componentCount;
            const avgPhase = spectralPhase / componentCount;
            
            // Normalize and combine
            const magnitudeScore = Math.min(100, avgMagnitude / 10);
            const phaseScore = Math.min(100, avgPhase * 50 / Math.PI);
            
            return (magnitudeScore + phaseScore) / 2;
        }

        async function analyzeAdvancedColor(regions) {
            // Advanced color analysis
            let totalScore = 0;
            let totalWeight = 0;
            
            for (const region of regions) {
                const canvas = region.canvas;
                
                // Color histogram analysis
                const histogramScore = analyzeColorHistogram(canvas);
                
                // Color moment analysis
                const momentScore = analyzeColorMoments(canvas);
                
                // Color coherence analysis
                const coherenceScore = analyzeColorCoherence(canvas);
                
                const regionScore = (histogramScore + momentScore + coherenceScore) / 3;
                totalScore += regionScore * region.weight;
                totalWeight += region.weight;
            }
            
            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        function analyzeColorHistogram(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const histR = new Array(256).fill(0);
            const histG = new Array(256).fill(0);
            const histB = new Array(256).fill(0);
            
            let totalPixels = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                histR[data[i]]++;
                histG[data[i + 1]]++;
                histB[data[i + 2]]++;
                totalPixels++;
            }
            
            // Calculate histogram uniformity
            let uniformityR = 0, uniformityG = 0, uniformityB = 0;
            
            for (let i = 0; i < 256; i++) {
                const probR = histR[i] / totalPixels;
                const probG = histG[i] / totalPixels;
                const probB = histB[i] / totalPixels;
                
                if (probR > 0) uniformityR += probR * probR;
                if (probG > 0) uniformityG += probG * probG;
                if (probB > 0) uniformityB += probB * probB;
            }
            
            const avgUniformity = (uniformityR + uniformityG + uniformityB) / 3;
            
            // Convert to score (lower uniformity = more diverse colors = higher score)
            return Math.max(0, Math.min(100, (1 - avgUniformity) * 100));
        }

        function analyzeColorMoments(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let meanR = 0, meanG = 0, meanB = 0;
            let stdR = 0, stdG = 0, stdB = 0;
            let skewR = 0, skewG = 0, skewB = 0;
            
            const totalPixels = data.length / 4;
            
            // Calculate means
            for (let i = 0; i < data.length; i += 4) {
                meanR += data[i];
                meanG += data[i + 1];
                meanB += data[i + 2];
            }
            
            meanR /= totalPixels;
            meanG /= totalPixels;
            meanB /= totalPixels;
            
            // Calculate standard deviation and skewness
            for (let i = 0; i < data.length; i += 4) {
                const diffR = data[i] - meanR;
                const diffG = data[i + 1] - meanG;
                const diffB = data[i + 2] - meanB;
                
                stdR += diffR * diffR;
                stdG += diffG * diffG;
                stdB += diffB * diffB;
                
                skewR += diffR * diffR * diffR;
                skewG += diffG * diffG * diffG;
                skewB += diffB * diffB * diffB;
            }
            
            stdR = Math.sqrt(stdR / totalPixels);
            stdG = Math.sqrt(stdG / totalPixels);
            stdB = Math.sqrt(stdB / totalPixels);
            
            if (stdR > 0) skewR = skewR / (totalPixels * stdR * stdR * stdR);
            if (stdG > 0) skewG = skewG / (totalPixels * stdG * stdG * stdG);
            if (stdB > 0) skewB = skewB / (totalPixels * stdB * stdB * stdB);
            
            // Combine moments into score
            const avgStd = (stdR + stdG + stdB) / 3;
            const avgSkew = Math.abs(skewR) + Math.abs(skewG) + Math.abs(skewB);
            
            const stdScore = Math.min(100, avgStd / 2);
            const skewScore = Math.max(0, 100 - avgSkew * 10);
            
            return (stdScore + skewScore) / 2;
        }

        function analyzeColorCoherence(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let coherentPixels = 0;
            let totalPixels = 0;
            
            const visited = new Array(width * height).fill(false);
            const colorThreshold = 30;
            
            // Check color coherence by finding connected regions
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (visited[idx]) continue;
                    
                    const regionSize = floodFill(data, visited, x, y, width, height, colorThreshold);
                    
                    if (regionSize > 10) { // Minimum region size for coherence
                        coherentPixels += regionSize;
                    }
                    totalPixels += regionSize;
                }
            }
            
            const coherenceRatio = totalPixels > 0 ? coherentPixels / totalPixels : 0;
            return coherenceRatio * 100;
        }

        function floodFill(data, visited, startX, startY, width, height, threshold) {
            const stack = [{x: startX, y: startY}];
            const targetColor = {
                r: data[(startY * width + startX) * 4],
                g: data[(startY * width + startX) * 4 + 1],
                b: data[(startY * width + startX) * 4 + 2]
            };
            
            let regionSize = 0;
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                
                const idx = y * width + x;
                if (visited[idx]) continue;
                
                const pixelColor = {
                    r: data[idx * 4],
                    g: data[idx * 4 + 1],
                    b: data[idx * 4 + 2]
                };
                
                const colorDistance = Math.sqrt(
                    (pixelColor.r - targetColor.r) ** 2 +
                    (pixelColor.g - targetColor.g) ** 2 +
                    (pixelColor.b - targetColor.b) ** 2
                );
                
                if (colorDistance > threshold) continue;
                
                visited[idx] = true;
                regionSize++;
                
                // Add neighbors to stack
                stack.push({x: x + 1, y});
                stack.push({x: x - 1, y});
                stack.push({x, y: y + 1});
                stack.push({x, y: y - 1});
            }
            
            return regionSize;
        }

        async function detectAdvancedForgery(regions, docType) {
            // Advanced forgery detection algorithms
            let totalScore = 0;
            let totalWeight = 0;
            
            for (const region of regions) {
                const canvas = region.canvas;
                
                // JPEG compression artifacts
                const jpegScore = detectJPEGArtifacts(canvas);
                
                // Copy-move detection
                const copyMoveScore = detectCopyMove(canvas);
                
                // Inconsistent noise patterns
                const noiseScore = detectNoiseInconsistency(canvas);
                
                // Edge inconsistency
                const edgeScore = detectEdgeInconsistency(canvas);
                
                const regionScore = (jpegScore + copyMoveScore + noiseScore + edgeScore) / 4;
                totalScore += regionScore * region.weight;
                totalWeight += region.weight;
            }
            
            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        function detectJPEGArtifacts(canvas) {
            // Detect JPEG compression artifacts that may indicate tampering
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let artifactScore = 0;
            let blockCount = 0;
            
            // Check for 8x8 block boundaries typical of JPEG
            for (let y = 0; y < height - 8; y += 8) {
                for (let x = 0; x < width - 8; x += 8) {
                    // Check boundary discontinuities
                    let boundaryDiff = 0;
                    
                    // Right boundary
                    for (let i = 0; i < 8; i++) {
                        const idx1 = ((y + i) * width + (x + 7)) * 4;
                        const idx2 = ((y + i) * width + (x + 8)) * 4;
                        if (x + 8 < width) {
                            boundaryDiff += Math.abs(data[idx1] - data[idx2]);
                        }
                    }
                    
                    // Bottom boundary
                    for (let i = 0; i < 8; i++) {
                        const idx1 = ((y + 7) * width + (x + i)) * 4;
                        const idx2 = ((y + 8) * width + (x + i)) * 4;
                        if (y + 8 < height) {
                            boundaryDiff += Math.abs(data[idx1] - data[idx2]);
                        }
                    }
                    
                    artifactScore += boundaryDiff;
                    blockCount++;
                }
            }
            
            const avgArtifact = blockCount > 0 ? artifactScore / blockCount : 0;
            
            // Higher artifacts may indicate tampering, but some artifacts are normal
            // Return consistency score (lower artifacts = more consistent = higher score)
            return Math.max(0, Math.min(100, 100 - (avgArtifact / 50)));
        }

        function detectCopyMove(canvas) {
            // Simplified copy-move forgery detection
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            const blockSize = 16;
            const blocks = [];
            
            // Extract blocks
            for (let y = 0; y < height - blockSize; y += 4) {
                for (let x = 0; x < width - blockSize; x += 4) {
                    const block = extractBlockFeatures(data, x, y, width, blockSize);
                    blocks.push({x, y, features: block});
                }
            }
            
            // Find similar blocks
            let similarPairs = 0;
            const threshold = 500; // Similarity threshold
            
            for (let i = 0; i < blocks.length; i++) {
                for (let j = i + 1; j < blocks.length; j++) {
                    const distance = calculateBlockDistance(blocks[i].features, blocks[j].features);
                    
                    if (distance < threshold) {
                        const spatialDistance = Math.sqrt(
                            (blocks[i].x - blocks[j].x) ** 2 + 
                            (blocks[i].y - blocks[j].y) ** 2
                        );
                        
                        // Only count as suspicious if blocks are far apart
                        if (spatialDistance > blockSize * 2) {
                            similarPairs++;
                        }
                    }
                }
            }
            
            // Higher number of similar distant blocks indicates potential copy-move
            const suspicionLevel = Math.min(100, (similarPairs / blocks.length) * 1000);
            return Math.max(0, 100 - suspicionLevel);
        }

        function extractBlockFeatures(data, startX, startY, width, blockSize) {
            const features = [];
            
            for (let y = 0; y < blockSize; y += 2) {
                for (let x = 0; x < blockSize; x += 2) {
                    const idx = ((startY + y) * width + (startX + x)) * 4;
                    if (idx < data.length) {
                        features.push(data[idx]); // Red channel
                    }
                }
            }
            
            return features;
        }

        function calculateBlockDistance(features1, features2) {
            let distance = 0;
            const minLength = Math.min(features1.length, features2.length);
            
            for (let i = 0; i < minLength; i++) {
                distance += (features1[i] - features2[i]) ** 2;
            }
            
            return Math.sqrt(distance);
        }

        function detectNoiseInconsistency(canvas) {
            // Detect inconsistent noise patterns that may indicate tampering
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            const regionSize = 32;
            const noiseEstimates = [];
            
            // Estimate noise in different regions
            for (let y = 0; y < height - regionSize; y += regionSize) {
                for (let x = 0; x < width - regionSize; x += regionSize) {
                    const noise = estimateRegionNoise(data, x, y, width, regionSize);
                    noiseEstimates.push(noise);
                }
            }
            
            if (noiseEstimates.length === 0) return 50;
            
            // Calculate noise consistency
            const meanNoise = noiseEstimates.reduce((a, b) => a + b) / noiseEstimates.length;
            let variance = 0;
            
            for (const noise of noiseEstimates) {
                variance += (noise - meanNoise) ** 2;
            }
            
            variance /= noiseEstimates.length;
            const stdDev = Math.sqrt(variance);
            
            // Lower standard deviation indicates more consistent noise
            const consistency = Math.max(0, 100 - (stdDev / meanNoise) * 100);
            return Math.min(100, consistency);
        }

        function estimateRegionNoise(data, startX, startY, width, regionSize) {
            // Estimate noise using Laplacian operator
            let noiseSum = 0;
            let pixelCount = 0;
            
            for (let y = startY + 1; y < startY + regionSize - 1; y++) {
                for (let x = startX + 1; x < startX + regionSize - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const center = data[idx];
                    
                    const laplacian = Math.abs(
                        4 * center - 
                        data[idx - 4] - // left
                        data[idx + 4] - // right
                        data[idx - width * 4] - // up
                        data[idx + width * 4]   // down
                    );
                    
                    noiseSum += laplacian;
                    pixelCount++;
                }
            }
            
            return pixelCount > 0 ? noiseSum / pixelCount : 0;
        }

        function detectEdgeInconsistency(canvas) {
            // Detect inconsistent edge patterns
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            const edgeMap = [];
            
            // Calculate edge strength using Sobel operator
            for (let y = 1; y < height - 1; y++) {
                edgeMap[y] = [];
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Sobel X
                    const gx = -data[idx - width * 4 - 4] + data[idx - width * 4 + 4] +
                              -2 * data[idx - 4] + 2 * data[idx + 4] +
                              -data[idx + width * 4 - 4] + data[idx + width * 4 + 4];
                    
                    // Sobel Y
                    const gy = -data[idx - width * 4 - 4] - 2 * data[idx - width * 4] - data[idx - width * 4 + 4] +
                               data[idx + width * 4 - 4] + 2 * data[idx + width * 4] + data[idx + width * 4 + 4];
                    
                    edgeMap[y][x] = Math.sqrt(gx * gx + gy * gy);
                }
            }
            
            // Analyze edge consistency in overlapping regions
            const regionSize = 64;
            const edgeVariances = [];
            
            for (let y = 0; y < height - regionSize; y += regionSize / 2) {
                for (let x = 0; x < width - regionSize; x += regionSize / 2) {
                    const variance = calculateEdgeVariance(edgeMap, x, y, regionSize);
                    edgeVariances.push(variance);
                }
            }
            
            if (edgeVariances.length === 0) return 50;
            
            // Calculate consistency of edge variances
            const meanVariance = edgeVariances.reduce((a, b) => a + b) / edgeVariances.length;
            let varianceOfVariances = 0;
            
            for (const variance of edgeVariances) {
                varianceOfVariances += (variance - meanVariance) ** 2;
            }
            
            varianceOfVariances /= edgeVariances.length;
            
            // Lower variance of variances indicates more consistent edge patterns
            const consistency = Math.max(0, 100 - Math.sqrt(varianceOfVariances) / 10);
            return Math.min(100, consistency);
        }

        function calculateEdgeVariance(edgeMap, startX, startY, regionSize) {
            let sum = 0;
            let sumSquares = 0;
            let count = 0;
            
            for (let y = startY; y < startY + regionSize && y < edgeMap.length; y++) {
                if (!edgeMap[y]) continue;
                for (let x = startX; x < startX + regionSize && x < edgeMap[y].length; x++) {
                    const value = edgeMap[y][x];
                    sum += value;
                    sumSquares += value * value;
                    count++;
                }
            }
            
            if (count === 0) return 0;
            
            const mean = sum / count;
            const variance = (sumSquares / count) - (mean * mean);
            return variance;
        }

        async function analyzeGeometry(regions) {
            // Geometric analysis for layout consistency
            let totalScore = 0;
            let totalWeight = 0;
            
            for (const region of regions) {
                const canvas = region.canvas;
                
                // Symmetry analysis
                const symmetryScore = analyzeSymmetry(canvas);
                
                // Proportion analysis
                const proportionScore = analyzeProportions(canvas);
                
                // Alignment analysis
                const alignmentScore = analyzeAlignment(canvas);
                
                const regionScore = (symmetryScore + proportionScore + alignmentScore) / 3;
                totalScore += regionScore * region.weight;
                totalWeight += region.weight;
            }
            
            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        function analyzeSymmetry(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let horizontalSymmetry = 0;
            let verticalSymmetry = 0;
            let totalComparisons = 0;
            
            // Horizontal symmetry (left-right)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width / 2; x++) {
                    const leftIdx = (y * width + x) * 4;
                    const rightIdx = (y * width + (width - 1 - x)) * 4;
                    
                    const leftGray = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
                    const rightGray = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                    
                    const diff = Math.abs(leftGray - rightGray);
                    horizontalSymmetry += Math.max(0, 255 - diff);
                    totalComparisons++;
                }
            }
            
            // Vertical symmetry (top-bottom)
            for (let y = 0; y < height / 2; y++) {
                for (let x = 0; x < width; x++) {
                    const topIdx = (y * width + x) * 4;
                    const bottomIdx = ((height - 1 - y) * width + x) * 4;
                    
                    const topGray = (data[topIdx] + data[topIdx + 1] + data[topIdx + 2]) / 3;
                    const bottomGray = (data[bottomIdx] + data[bottomIdx + 1] + data[bottomIdx + 2]) / 3;
                    
                    const diff = Math.abs(topGray - bottomGray);
                    verticalSymmetry += Math.max(0, 255 - diff);
                }
            }
            
            const avgHorizontal = totalComparisons > 0 ? horizontalSymmetry / totalComparisons : 0;
            const avgVertical = totalComparisons > 0 ? verticalSymmetry / totalComparisons : 0;
            
            return Math.max(avgHorizontal, avgVertical) / 255 * 100;
        }

        function analyzeProportions(canvas) {
            // Analyze golden ratio and other common proportions
            const width = canvas.width;
            const height = canvas.height;
            
            const aspectRatio = width / height;
            const goldenRatio = 1.618;
            
            // Check proximity to golden ratio
            const goldenDiff = Math.abs(aspectRatio - goldenRatio);
            const goldenScore = Math.max(0, 100 - goldenDiff * 50);
            
            // Check proximity to common document ratios
            const commonRatios = [1.0, 1.33, 1.41, 1.5, 1.77]; // 1:1, 4:3, √2:1, 3:2, 16:9
            let bestRatioScore = 0;
            
            for (const ratio of commonRatios) {
                const diff = Math.abs(aspectRatio - ratio);
                const score = Math.max(0, 100 - diff * 100);
                bestRatioScore = Math.max(bestRatioScore, score);
            }
            
            return Math.max(goldenScore, bestRatioScore);
        }

        function analyzeAlignment(canvas) {
            // Analyze alignment of major elements
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Find major horizontal and vertical lines
            const horizontalLines = [];
            const verticalLines = [];
            
            // Detect horizontal lines
            for (let y = 0; y < height; y += 5) {
                let lineStrength = 0;
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const leftGray = (data[idx - 4] + data[idx - 3] + data[idx - 2]) / 3;
                    const rightGray = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
                    const centerGray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    if (Math.abs(leftGray - rightGray) < 20 && 
                        (Math.abs(centerGray - leftGray) > 30 || Math.abs(centerGray - rightGray) > 30)) {
                        lineStrength++;
                    }
                }
                
                if (lineStrength > width * 0.3) {
                    horizontalLines.push(y);
                }
            }
            
            // Detect vertical lines
            for (let x = 0; x < width; x += 5) {
                let lineStrength = 0;
                for (let y = 1; y < height - 1; y++) {
                    const idx = (y * width + x) * 4;
                    const topGray = (data[idx - width * 4] + data[idx - width * 4 + 1] + data[idx - width * 4 + 2]) / 3;
                    const bottomGray = (data[idx + width * 4] + data[idx + width * 4 + 1] + data[idx + width * 4 + 2]) / 3;
                    const centerGray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    if (Math.abs(topGray - bottomGray) < 20 && 
                        (Math.abs(centerGray - topGray) > 30 || Math.abs(centerGray - bottomGray) > 30)) {
                        lineStrength++;
                    }
                }
                
                if (lineStrength > height * 0.3) {
                    verticalLines.push(x);
                }
            }
            
            // Calculate alignment score based on line regularity
            let alignmentScore = 50; // Base score
            
            if (horizontalLines.length > 1) {
                const horizontalSpacing = [];
                for (let i = 1; i < horizontalLines.length; i++) {
                    horizontalSpacing.push(horizontalLines[i] - horizontalLines[i - 1]);
                }
                const avgSpacing = horizontalSpacing.reduce((a, b) => a + b) / horizontalSpacing.length;
                let spacingVariance = 0;
                for (const spacing of horizontalSpacing) {
                    spacingVariance += (spacing - avgSpacing) ** 2;
                }
                spacingVariance /= horizontalSpacing.length;
                
                alignmentScore += Math.max(0, 25 - Math.sqrt(spacingVariance) / 5);
            }
            
            if (verticalLines.length > 1) {
                const verticalSpacing = [];
                for (let i = 1; i < verticalLines.length; i++) {
                    verticalSpacing.push(verticalLines[i] - verticalLines[i - 1]);
                }
                const avgSpacing = verticalSpacing.reduce((a, b) => a + b) / verticalSpacing.length;
                let spacingVariance = 0;
                for (const spacing of verticalSpacing) {
                    spacingVariance += (spacing - avgSpacing) ** 2;
                }
                spacingVariance /= verticalSpacing.length;
                
                alignmentScore += Math.max(0, 25 - Math.sqrt(spacingVariance) / 5);
            }
            
            return Math.min(100, alignmentScore);
        }

        async function analyzeSecurityFeatures(regions, docType) {
            // Security features analysis based on document type
            let totalScore = 0;
            let totalWeight = 0;
            
            for (const region of regions) {
                const canvas = region.canvas;
                
                let securityScore = 0;
                
                if (docType === 'currency') {
                    // Currency-specific security features
                    const watermarkScore = detectWatermarks(canvas);
                    const micropatternScore = detectMicropatterns(canvas);
                    const iridescentScore = detectIridescentPatterns(canvas);
                    
                    securityScore = (watermarkScore + micropatternScore + iridescentScore) / 3;
                } else if (docType === 'document') {
                    // Document-specific security features
                    const sealScore = detectSealsStamps(canvas);
                    const embossScore = detectEmbossing(canvas);
                    const hologramScore = detectHolograms(canvas);
                    
                    securityScore = (sealScore + embossScore + hologramScore) / 3;
                } else {
                    // General security features
                    const generalScore = detectGeneralSecurity(canvas);
                    securityScore = generalScore;
                }
                
                totalScore += securityScore * region.weight;
                totalWeight += region.weight;
            }
            
            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        function detectWatermarks(canvas) {
            // Detect watermark-like patterns (low contrast, large area features)
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let watermarkIndicators = 0;
            let totalPixels = 0;
            
            // Look for subtle patterns with low contrast
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    // Calculate local variance
                    let localVariance = 0;
                    let neighborCount = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            const nGray = (data[nIdx] + data[nIdx + 1] + data[nIdx + 2]) / 3;
                            localVariance += (gray - nGray) ** 2;
                            neighborCount++;
                        }
                    }
                    
                    localVariance /= neighborCount;
                    
                    // Watermarks typically have low but consistent variance
                    if (localVariance > 10 && localVariance < 100) {
                        watermarkIndicators++;
                    }
                    
                    totalPixels++;
                }
            }
            
            const watermarkRatio = totalPixels > 0 ? watermarkIndicators / totalPixels : 0;
            return Math.min(100, watermarkRatio * 500); // Scale up
        }

        function detectMicropatterns(canvas) {
            // Detect micro-patterns typical in currency security features
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let micropatternScore = 0;
            let regionCount = 0;
            
            // Analyze small regions for repetitive micro-patterns
            const regionSize = 16;
            for (let y = 0; y < height - regionSize; y += regionSize / 2) {
                for (let x = 0; x < width - regionSize; x += regionSize / 2) {
                    const pattern = extractMicropattern(data, x, y, width, regionSize);
                    const repetitiveness = calculatePatternRepetition(pattern);
                    
                    if (repetitiveness > 0.7) { // High repetition indicates micro-pattern
                        micropatternScore++;
                    }
                    regionCount++;
                }
            }
            
            const micropatternRatio = regionCount > 0 ? micropatternScore / regionCount : 0;
            return micropatternRatio * 100;
        }

        function extractMicropattern(data, startX, startY, width, regionSize) {
            const pattern = [];
            
            for (let y = 0; y < regionSize; y += 2) {
                for (let x = 0; x < regionSize; x += 2) {
                    const idx = ((startY + y) * width + (startX + x)) * 4;
                    if (idx < data.length) {
                        pattern.push((data[idx] + data[idx + 1] + data[idx + 2]) / 3);
                    }
                }
            }
            
            return pattern;
        }

        function calculatePatternRepetition(pattern) {
            if (pattern.length < 4) return 0;
            
            let maxRepetition = 0;
            
            // Check for repeating sub-patterns
            for (let patternLength = 2; patternLength <= pattern.length / 2; patternLength++) {
                let repetitions = 0;
                let totalChecks = 0;
                
                for (let start = 0; start <= pattern.length - patternLength * 2; start++) {
                    let matches = 0;
                    
                    for (let i = 0; i < patternLength; i++) {
                        if (Math.abs(pattern[start + i] - pattern[start + patternLength + i]) < 10) {
                            matches++;
                        }
                    }
                    
                    if (matches / patternLength > 0.8) {
                        repetitions++;
                    }
                    totalChecks++;
                }
                
                const repetitionRatio = totalChecks > 0 ? repetitions / totalChecks : 0;
                maxRepetition = Math.max(maxRepetition, repetitionRatio);
            }
            
            return maxRepetition;
        }

        function detectIridescentPatterns(canvas) {
            // Detect iridescent/holographic patterns (color changes)
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let colorChangeIndicators = 0;
            let totalRegions = 0;
            
            const regionSize = 20;
            for (let y = 0; y < height - regionSize; y += regionSize) {
                for (let x = 0; x < width - regionSize; x += regionSize) {
                    const colorVariation = calculateColorVariation(data, x, y, width, regionSize);
                    
                    // High color variation might indicate iridescent features
                    if (colorVariation > 0.3) {
                        colorChangeIndicators++;
                    }
                    totalRegions++;
                }
            }
            
            const iridescentRatio = totalRegions > 0 ? colorChangeIndicators / totalRegions : 0;
            return iridescentRatio * 100;
        }

        function calculateColorVariation(data, startX, startY, width, regionSize) {
            let rVariance = 0, gVariance = 0, bVariance = 0;
            let rSum = 0, gSum = 0, bSum = 0;
            let pixelCount = 0;
            
            // Calculate means
            for (let y = 0; y < regionSize; y++) {
                for (let x = 0; x < regionSize; x++) {
                    const idx = ((startY + y) * width + (startX + x)) * 4;
                    if (idx < data.length) {
                        rSum += data[idx];
                        gSum += data[idx + 1];
                        bSum += data[idx + 2];
                        pixelCount++;
                    }
                }
            }
            
            if (pixelCount === 0) return 0;
            
            const rMean = rSum / pixelCount;
            const gMean = gSum / pixelCount;
            const bMean = bSum / pixelCount;
            
            // Calculate variances
            for (let y = 0; y < regionSize; y++) {
                for (let x = 0; x < regionSize; x++) {
                    const idx = ((startY + y) * width + (startX + x)) * 4;
                    if (idx < data.length) {
                        rVariance += (data[idx] - rMean) ** 2;
                        gVariance += (data[idx + 1] - gMean) ** 2;
                        bVariance += (data[idx + 2] - bMean) ** 2;
                    }
                }
            }
            
            rVariance = Math.sqrt(rVariance / pixelCount);
            gVariance = Math.sqrt(gVariance / pixelCount);
            bVariance = Math.sqrt(bVariance / pixelCount);
            
            return (rVariance + gVariance + bVariance) / (3 * 255); // Normalize
        }

        function detectSealsStamps(canvas) {
            // Detect circular/oval seals and stamps
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let circularFeatures = 0;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Check for circular patterns at different radii
            for (let radius = 20; radius < Math.min(width, height) / 3; radius += 10) {
                let circleStrength = 0;
                let edgePoints = 0;
                
                for (let angle = 0; angle < 360; angle += 5) {
                    const x = Math.round(centerX + radius * Math.cos(angle * Math.PI / 180));
                    const y = Math.round(centerY + radius * Math.sin(angle * Math.PI / 180));
                    
                    if (x >= 1 && x < width - 1 && y >= 1 && y < height - 1) {
                        const idx = (y * width + x) * 4;
                        
                        // Check for edge-like features (potential seal outline)
                        const centerGray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        const innerIdx = ((y - Math.round(Math.sin(angle * Math.PI / 180) * 5)) * width + 
                                         (x - Math.round(Math.cos(angle * Math.PI / 180) * 5))) * 4;
                        const outerIdx = ((y + Math.round(Math.sin(angle * Math.PI / 180) * 5)) * width + 
                                         (x + Math.round(Math.cos(angle * Math.PI / 180) * 5))) * 4;
                        
                        if (innerIdx >= 0 && innerIdx < data.length && outerIdx >= 0 && outerIdx < data.length) {
                            const innerGray = (data[innerIdx] + data[innerIdx + 1] + data[innerIdx + 2]) / 3;
                            const outerGray = (data[outerIdx] + data[outerIdx + 1] + data[outerIdx + 2]) / 3;
                            
                            const edgeStrength = Math.abs(innerGray - outerGray);
                            if (edgeStrength > 30) {
                                circleStrength++;
                            }
                        }
                        edgePoints++;
                    }
                }
                
                if (edgePoints > 0 && (circleStrength / edgePoints) > 0.3) {
                    circularFeatures++;
                }
            }
            
            return Math.min(100, circularFeatures * 10);
        }

        function detectEmbossing(canvas) {
            // Detect embossed text or patterns (subtle height differences)
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let embossIndicators = 0;
            let totalPixels = 0;
            
            // Look for patterns typical of embossing (subtle shadows/highlights)
            for (let y = 2; y < height - 2; y++) {
                for (let x = 2; x < width - 2; x++) {
                    const idx = (y * width + x) * 4;
                    const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    // Check for emboss-like patterns (light-dark transitions)
                    const topLeft = (data[idx - width * 4 - 4] + data[idx - width * 4 - 3] + data[idx - width * 4 - 2]) / 3;
                    const bottomRight = (data[idx + width * 4 + 4] + data[idx + width * 4 + 5] + data[idx + width * 4 + 6]) / 3;
                    
                    const embossGradient = topLeft - bottomRight;
                    
                    // Embossing typically creates specific gradient patterns
                    if (Math.abs(embossGradient) > 15 && Math.abs(embossGradient) < 60) {
                        embossIndicators++;
                    }
                    totalPixels++;
                }
            }
            
            const embossRatio = totalPixels > 0 ? embossIndicators / totalPixels : 0;
            return Math.min(100, embossRatio * 200);
        }

        function detectHolograms(canvas) {
            // Detect holographic patterns (rainbow-like color shifts)
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            let hologramIndicators = 0;
            let totalRegions = 0;
            
            const regionSize = 25;
            for (let y = 0; y < height - regionSize; y += regionSize) {
                for (let x = 0; x < width - regionSize; x += regionSize) {
                    const colorSpread = calculateColorSpread(data, x, y, width, regionSize);
                    
                    // Holograms typically show high color spread with specific patterns
                    if (colorSpread > 0.4) {
                        hologramIndicators++;
                    }
                    totalRegions++;
                }
            }
            
            const hologramRatio = totalRegions > 0 ? hologramIndicators / totalRegions : 0;
            return hologramRatio * 100;
        }

        function calculateColorSpread(data, startX, startY, width, regionSize) {
            let minR = 255, maxR = 0;
            let minG = 255, maxG = 0;
            let minB = 255, maxB = 0;
            
            for (let y = 0; y < regionSize; y++) {
                for (let x = 0; x < regionSize; x++) {
                    const idx = ((startY + y) * width + (startX + x)) * 4;
                    if (idx < data.length) {
                        minR = Math.min(minR, data[idx]);
                        maxR = Math.max(maxR, data[idx]);
                        minG = Math.min(minG, data[idx + 1]);
                        maxG = Math.max(maxG, data[idx + 1]);
                        minB = Math.min(minB, data[idx + 2]);
                        maxB = Math.max(maxB, data[idx + 2]);
                    }
                }
            }
            
            const rSpread = (maxR - minR) / 255;
            const gSpread = (maxG - minG) / 255;
            const bSpread = (maxB - minB) / 255;
            
            return (rSpread + gSpread + bSpread) / 3;
        }

        function detectGeneralSecurity(canvas) {
            // General security feature detection
            const watermarkScore = detectWatermarks(canvas);
            const patternScore = detectMicropatterns(canvas);
            const colorScore = detectIridescentPatterns(canvas);
            
            return (watermarkScore + patternScore + colorScore) / 3;
        }

        function getAnalysisWeights(docType) {
            if (docType === 'currency') {
                return {
                    texture: 0.15,
                    frequency: 0.15,
                    color: 0.20,
                    forgery: 0.25,
                    geometry: 0.10,
                    security: 0.15
                };
            } else if (docType === 'document') {
                return {
                    texture: 0.20,
                    frequency: 0.15,
                    color: 0.15,
                    forgery: 0.25,
                    geometry: 0.15,
                    security: 0.10
                };
            } else {
                return {
                    texture: 0.18,
                    frequency: 0.18,
                    color: 0.18,
                    forgery: 0.23,
                    geometry: 0.13,
                    security: 0.10
                };
            }
        }

        function calculateWeightedScore(metrics, weights) {
            let totalScore = 0;
            let totalWeight = 0;
            
            for (const [metric, score] of Object.entries(metrics)) {
                if (weights[metric]) {
                    totalScore += score * weights[metric];
                    totalWeight += weights[metric];
                }
            }
            
            return totalWeight > 0 ? totalScore / totalWeight : 0;
        }

        async function createAdvancedVisualResults(regions) {
            // Create advanced visual comparison results
            const results = {
                regions: [],
                heatmaps: [],
                differences: [],
                overlays: []
            };
            
            for (let i = 0; i < regions.length; i++) {
                const region = regions[i];
                
                // Create region visualization
                results.regions.push({
                    canvas: region.canvas,
                    type: region.type,
                    weight: region.weight,
                    dataURL: region.canvas.toDataURL()
                });
                
                // Create difference maps between similar regions
                if (i < regions.length - 1) {
                    const nextRegion = regions[i + 1];
                    const diffMap = createRegionDifference(region.canvas, nextRegion.canvas);
                    results.differences.push({
                        dataURL: diffMap,
                        types: [region.type, nextRegion.type]
                    });
                }
                
                // Create analysis overlay
                const overlay = createAnalysisOverlay(region.canvas);
                results.overlays.push({
                    dataURL: overlay,
                    type: region.type
                });
            }
            
            return results;
        }

        function createRegionDifference(canvas1, canvas2) {
            const width = Math.min(canvas1.width, canvas2.width);
            const height = Math.min(canvas1.height, canvas2.height);
            
            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = width;
            outputCanvas.height = height;
            const outCtx = outputCanvas.getContext('2d');
            
            const ctx1 = canvas1.getContext('2d');
            const ctx2 = canvas2.getContext('2d');
            
            const data1 = ctx1.getImageData(0, 0, width, height).data;
            const data2 = ctx2.getImageData(0, 0, width, height).data;
            
            const output = outCtx.createImageData(width, height);
            
            for (let i = 0; i < data1.length; i += 4) {
                const r1 = data1[i], g1 = data1[i + 1], b1 = data1[i + 2];
                const r2 = data2[i], g2 = data2[i + 1], b2 = data2[i + 2];
                
                const diff = Math.sqrt((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2) / (255 * Math.sqrt(3));
                
                // Create heat map colors
                if (diff < 0.1) {
                    output.data[i] = 0;       // R
                    output.data[i + 1] = 255; // G
                    output.data[i + 2] = 0;   // B
                } else if (diff < 0.3) {
                    output.data[i] = 255;     // R
                    output.data[i + 1] = 255; // G
                    output.data[i + 2] = 0;   // B
                } else {
                    output.data[i] = 255;     // R
                    output.data[i + 1] = 0;   // G
                    output.data[i + 2] = 0;   // B
                }
                output.data[i + 3] = 200; // Semi-transparent
            }
            
            outCtx.putImageData(output, 0, 0);
            return outputCanvas.toDataURL();
        }

        function createAnalysisOverlay(canvas) {
            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = canvas.width;
            outputCanvas.height = canvas.height;
            const ctx = outputCanvas.getContext('2d');
            
            // Draw original image
            ctx.drawImage(canvas, 0, 0);
            
            // Add analysis overlay
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#5D5CDE';
            
            // Add grid overlay for analysis visualization
            const gridSize = 20;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1.0;
            
            return outputCanvas.toDataURL();
        }

        function displayAdvancedResults(results) {
            document.getElementById('progressSection').classList.add('hidden');
            document.getElementById('resultSection').classList.remove('hidden');

            const { documentType, score, regions, metrics, visual, weights } = results;

            // Display document type detection results
            displayDocumentTypeResults(documentType);

            // Display overall score
            displayOverallScore(score, documentType);

            // Display detailed metrics
            displayDetailedMetrics(metrics, weights);

            // Display region analysis
            displayRegionAnalysis(regions, visual);

            // Display visual comparison
            displayVisualComparison(visual);

            // Scroll to results
            document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
        }

        function displayDocumentTypeResults(documentType) {
            const container = document.getElementById('typeDetectionDisplay');
            
            let typeInfo, icon, badgeClass;
            
            switch (documentType) {
                case 'currency':
                    typeInfo = {
                        name: 'عملة ورقية',
                        description: 'تم اكتشاف خصائص العملات الورقية مثل الأنماط المعقدة والعلامات المائية',
                        features: ['أنماط أمنية معقدة', 'علامات مائية', 'ألوان متنوعة', 'تصميم متماثل']
                    };
                    icon = 'fas fa-coins';
                    badgeClass = 'badge-currency';
                    break;
                case 'document':
                    typeInfo = {
                        name: 'وثيقة رسمية',
                        description: 'تم اكتشاف خصائص المستندات الرسمية مثل النصوص والأختام',
                        features: ['نصوص منتظمة', 'أختام دائرية', 'هيكل مستطيل', 'طباعة عالية الجودة']
                    };
                    icon = 'fas fa-file-alt';
                    badgeClass = 'badge-document';
                    break;
                default:
                    typeInfo = {
                        name: 'نوع مختلط',
                        description: 'تم اكتشاف خصائص مختلطة أو غير محددة',
                        features: ['خصائص متنوعة', 'تصميم مختلط', 'عناصر متعددة']
                    };
                    icon = 'fas fa-question';
                    badgeClass = 'badge-mixed';
            }
            
            container.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="analysis-card p-6 rounded-lg">
                        <div class="flex items-center mb-4">
                            <div class="detection-badge ${badgeClass} mr-3">
                                <i class="${icon}"></i>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold">${typeInfo.name}</h3>
                                <p class="text-gray-600 dark:text-gray-400 text-sm">${typeInfo.description}</p>
                            </div>
                        </div>
                        <div class="space-y-2">
                            <h4 class="font-medium">الخصائص المكتشفة:</h4>
                            <ul class="text-sm text-gray-600 dark:text-gray-400">
                                ${typeInfo.features.map(feature => `<li>• ${feature}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                    
                    <div class="analysis-card p-6 rounded-lg">
                        <h4 class="font-bold mb-3 flex items-center">
                            <i class="fas fa-weight-hanging text-primary mr-2"></i>
                            أوزان التحليل المطبقة
                        </h4>
                        <div class="space-y-2">
                            ${Object.entries(weights).map(([key, weight]) => {
                                const labels = {
                                    texture: 'تحليل الملمس',
                                    frequency: 'التحليل الترددي',
                                    color: 'تحليل الألوان',
                                    forgery: 'كشف التزوير',
                                    geometry: 'التحليل الهندسي',
                                    security: 'الميزات الأمنية'
                                };
                                const percentage = (weight * 100).toFixed(0);
                                return `
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm">${labels[key]}</span>
                                        <span class="font-medium">${percentage}%</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function displayOverallScore(score, documentType) {
            const scoreDisplay = document.getElementById('scoreDisplay');
            const scoreInterpretation = document.getElementById('scoreInterpretation');

            let scoreClass, interpretation, icon;
            if (score >= 80) {
                scoreClass = 'result-excellent';
                interpretation = `✅ ${getDocTypeArabic(documentType)} يبدو أصلياً وسليماً. النتائج تشير إلى عدم وجود دلائل واضحة على التزوير.`;
                icon = 'fas fa-check-circle';
            } else if (score >= 60) {
                scoreClass = 'result-good';
                interpretation = `⚠️ ${getDocTypeArabic(documentType)} يحتوي على بعض الاختلافات الطفيفة. يُنصح بالفحص اليدوي الإضافي للتأكد.`;
                icon = 'fas fa-exclamation-triangle';
            } else {
                scoreClass = 'result-poor';
                interpretation = `🚨 احتمال التزوير مرتفع في ${getDocTypeArabic(documentType)}! توجد اختلافات كبيرة تشير إلى تلاعب محتمل.`;
                icon = 'fas fa-times-circle';
            }

            scoreDisplay.className = `text-center p-6 rounded-lg text-white font-bold text-3xl ${scoreClass}`;
            scoreDisplay.innerHTML = `
                <i class="${icon} mr-3"></i>
                ${score.toFixed(1)}%
                <div class="text-lg mt-2 opacity-90">تحليل متقدم - ${getDocTypeArabic(documentType)}</div>
            `;

            scoreInterpretation.className = `mt-4 p-4 rounded-lg border-r-4 ${score >= 80 ? 'bg-green-50 dark:bg-green-900/20 border-green-500' : score >= 60 ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-500' : 'bg-red-50 dark:bg-red-900/20 border-red-500'}`;
            scoreInterpretation.innerHTML = interpretation;
        }

        function displayDetailedMetrics(metrics, weights) {
            const metricsContainer = document.getElementById('detailedMetrics');
            const metricLabels = {
                texture: { name: 'تحليل الملمس المتقدم', icon: 'fas fa-texture', desc: 'LBP, Gabor, GLCM' },
                frequency: { name: 'التحليل الترددي', icon: 'fas fa-wave-square', desc: 'DCT, Wavelet, Spectral' },
                color: { name: 'تحليل الألوان', icon: 'fas fa-palette', desc: 'Histogram, Moments, Coherence' },
                forgery: { name: 'كشف التزوير', icon: 'fas fa-search', desc: 'JPEG, Copy-Move, Noise' },
                geometry: { name: 'التحليل الهندسي', icon: 'fas fa-vector-square', desc: 'Symmetry, Proportions, Alignment' },
                security: { name: 'الميزات الأمنية', icon: 'fas fa-shield-alt', desc: 'Watermarks, Patterns, Holograms' }
            };

            metricsContainer.innerHTML = Object.entries(metrics).map(([key, value]) => {
                const label = metricLabels[key];
                const weight = weights[key];
                const percentage = value.toFixed(1);
                const weightPercentage = (weight * 100).toFixed(0);
                const colorClass = value >= 75 ? 'text-green-600' : value >= 50 ? 'text-yellow-600' : 'text-red-600';
                
                return `
                    <div class="metric-card bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center">
                                <i class="${label.icon} text-primary mr-2"></i>
                                <div>
                                    <span class="font-medium">${label.name}</span>
                                    <div class="text-xs text-gray-500 dark:text-gray-400">${label.desc}</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <span class="font-bold ${colorClass}">${percentage}%</span>
                                <div class="text-xs text-gray-500 dark:text-gray-400">وزن: ${weightPercentage}%</div>
                            </div>
                        </div>
                        <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2">
                            <div class="bg-gradient-to-r from-primary to-purple-600 h-2 rounded-full transition-all duration-1000" style="width: ${value}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function displayRegionAnalysis(regions, visual) {
            const container = document.getElementById('regionAnalysis');
            
            container.innerHTML = `
                <div class="mb-4">
                    <p class="text-gray-600 dark:text-gray-400">
                        تم تحليل <strong>${regions.length}</strong> منطقة ذكية مختارة بناءً على نوع المستند والخصائص الهندسية
                    </p>
                </div>
                
                <div class="comparison-grid">
                    ${visual.regions.map((region, index) => `
                        <div class="image-preview">
                            <img src="${region.dataURL}" alt="المنطقة ${index + 1}">
                            <div class="image-label">
                                المنطقة ${index + 1}: ${getRegionTypeArabic(region.type)}
                                <br>الوزن: ${(region.weight * 100).toFixed(0)}%
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border border-blue-200 dark:border-blue-700">
                        <h4 class="font-bold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                            <i class="fas fa-info-circle mr-2"></i>
                            اختيار المناطق الذكية
                        </h4>
                        <ul class="text-blue-700 dark:text-blue-300 text-sm space-y-1">
                            <li>• تم اختيار المناطق بناءً على نوع المستند المكتشف</li>
                            <li>• كل منطقة لها وزن مختلف حسب أهميتها</li>
                            <li>• التحليل يركز على المناطق الحساسة للتزوير</li>
                        </ul>
                    </div>
                    
                    <div class="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg border border-green-200 dark:border-green-700">
                        <h4 class="font-bold text-green-800 dark:text-green-200 mb-2 flex items-center">
                            <i class="fas fa-chart-pie mr-2"></i>
                            توزيع الأوزان
                        </h4>
                        <div class="text-green-700 dark:text-green-300 text-sm space-y-1">
                            ${regions.map((region, index) => `
                                <div class="flex justify-between">
                                    <span>المنطقة ${index + 1}:</span>
                                    <span>${(region.weight * 100).toFixed(0)}%</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function getRegionTypeArabic(type) {
            const types = {
                'center': 'مركزية',
                'corner_tl': 'زاوية يسار أعلى',
                'corner_tr': 'زاوية يمين أعلى',
                'edge_left': 'حافة يسار',
                'edge_right': 'حافة يمين',
                'header': 'رأس المستند',
                'content': 'المحتوى الأساسي',
                'signature': 'منطقة التوقيع',
                'watermark': 'العلامة المائية'
            };
            
            if (type.startsWith('grid_')) {
                const [_, row, col] = type.split('_');
                return `شبكة (${parseInt(row) + 1}, ${parseInt(col) + 1})`;
            }
            
            return types[type] || type;
        }

        function displayVisualComparison(visual) {
            const visualComparison = document.getElementById('visualComparison');
            
            let comparisonHTML = '';
            
            if (visual.differences.length > 0) {
                comparisonHTML += `
                    <div class="mb-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center">
                            <i class="fas fa-exchange-alt text-primary mr-2"></i>
                            مقارنة الفروقات بين المناطق
                        </h3>
                        <div class="comparison-grid">
                            ${visual.differences.map((diff, index) => `
                                <div class="image-preview">
                                    <img src="${diff.dataURL}" alt="الفروقات ${index + 1}">
                                    <div class="image-label">
                                        فروقات: ${getRegionTypeArabic(diff.types[0])} ↔ ${getRegionTypeArabic(diff.types[1])}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (visual.overlays.length > 0) {
                comparisonHTML += `
                    <div class="mb-6">
                        <h3 class="text-lg font-bold mb-4 flex items-center">
                            <i class="fas fa-layer-group text-primary mr-2"></i>
                            تراكبات التحليل
                        </h3>
                        <div class="comparison-grid">
                            ${visual.overlays.slice(0, 6).map((overlay, index) => `
                                <div class="image-preview">
                                    <img src="${overlay.dataURL}" alt="تحليل ${index + 1}">
                                    <div class="image-label">
                                        تحليل: ${getRegionTypeArabic(overlay.type)}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            comparisonHTML += `
                <div class="bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-700 p-6">
                    <h4 class="font-bold text-blue-800 dark:text-blue-200 mb-4 flex items-center">
                        <i class="fas fa-graduation-cap mr-2"></i>
                        تفسير النتائج البصرية المتقدمة
                    </h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h5 class="font-medium text-blue-700 dark:text-blue-300 mb-2">خريطة الألوان:</h5>
                            <ul class="text-blue-600 dark:text-blue-400 text-sm space-y-1">
                                <li>🟢 <strong>أخضر:</strong> تطابق عالي (آمن)</li>
                                <li>🟡 <strong>أصفر:</strong> اختلافات طفيفة (انتباه)</li>
                                <li>🔴 <strong>أحمر:</strong> اختلافات كبيرة (مشكوك)</li>
                            </ul>
                        </div>
                        <div>
                            <h5 class="font-medium text-blue-700 dark:text-blue-300 mb-2">التحليل المتقدم:</h5>
                            <ul class="text-blue-600 dark:text-blue-400 text-sm space-y-1">
                                <li>• التحليل يعتمد على خوارزميات الذكاء الاصطناعي</li>
                                <li>• كل منطقة تحلل بخوارزميات متخصصة</li>
                                <li>• النتائج مرجحة حسب أهمية كل منطقة</li>
                                <li>• الدقة تزيد مع جودة الصورة</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            visualComparison.innerHTML = comparisonHTML;
        }

        function updateProgress(percentage, text) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            progressBar.style.width = percentage + '%';
            progressText.textContent = `${percentage}% - ${text}`;
        }

        async function loadImageToCanvas(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas);
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        async function loadImageFromDataURL(dataURL) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas);
                };
                img.onerror = reject;
                img.src = dataURL;
            });
        }

        function convertToGrayscale(canvas) {
            const newCanvas = document.createElement('canvas');
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;
            const ctx = newCanvas.getContext('2d');
            
            ctx.drawImage(canvas, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = gray;     // R
                data[i + 1] = gray; // G
                data[i + 2] = gray; // B
            }

            ctx.putImageData(imageData, 0, 0);
            return newCanvas;
        }

        // Additional analysis functions for backward compatibility
        async function analyzeCurrencyFeatures(regions) {
            // Currency-specific analysis (placeholder for specialized algorithms)
            return analyzeAdvancedTexture(regions);
        }

        async function analyzeDocumentFeatures(regions) {
            // Document-specific analysis (placeholder for specialized algorithms)
            return analyzeAdvancedTexture(regions);
        }

        async function analyzeGeneralFeatures(regions) {
            // General analysis (placeholder for mixed document types)
            return analyzeAdvancedTexture(regions);
        }

        function showCustomAlert(message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <div class="flex items-center mb-4">
                        <i class="fas fa-exclamation-triangle text-yellow-500 text-xl mr-3"></i>
                        <h3 class="font-bold text-lg">تنبيه</h3>
                    </div>
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-primary text-white hover:bg-purple-600 rounded transition-colors" onclick="this.closest('.fixed').remove()">حسناً</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
    </script>
</body>
</html>

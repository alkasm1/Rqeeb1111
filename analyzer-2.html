<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>كاشف المستندات المزورة - تحليل متقدم (OpenCV.js)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/4b9ba14b0f.js" crossorigin="anonymous"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .upload-area {
            border: 2px dashed #d1d5db;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #5D5CDE;
            background-color: rgba(93, 92, 222, 0.05);
        }
        .upload-area.dragover {
            border-color: #5D5CDE;
            background-color: rgba(93, 92, 222, 0.1);
        }
        .analysis-card {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%);
            border: 1px solid rgba(93, 92, 222, 0.2);
        }
        .progress-container {
            background: linear-gradient(90deg, #5D5CDE 0%, #9333EA 100%);
        }
        .result-excellent { background: linear-gradient(135deg, #10B981 0%, #059669 100%); }
        .result-good { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); }
        .result-poor { background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); }
        .metric-card {
            transition: all 0.3s ease;
            border: 1px solid rgba(93, 92, 222, 0.1);
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(93, 92, 222, 0.15);
        }
        .comparison-images {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }
        .image-preview {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        .image-preview img {
            width: 100%;
            height: auto;
            display: block;
        }
        .image-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
        }
        /* small helper for hidden canvas area */
        #internalCanvases { display:none; }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-primary to-purple-600 bg-clip-text text-transparent">
                <i class="fas fa-shield-alt mr-3"></i>
                كاشف المستندات المزورة
            </h1>
            <p class="text-gray-600 dark:text-gray-400 text-lg">
                تحليل متطور للكشف عن التزوير والتلاعب باستخدام OpenCV.js و خوارزميات نسيج، ألوان، وحواف
            </p>
        </div>

        <!-- Upload Section -->
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold mb-4 flex items-center">
                <i class="fas fa-upload mr-3 text-primary"></i>
                رفع الصورة للتحليل
            </h2>
            
            <div id="uploadArea" class="upload-area rounded-lg p-8 text-center cursor-pointer bg-gray-50 dark:bg-gray-700">
                <div id="uploadContent">
                    <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
                    <p class="text-lg font-medium text-gray-600 dark:text-gray-300 mb-2">
                        اسحب الصورة هنا أو انقر للاختيار
                    </p>
                    <p class="text-sm text-gray-500 dark:text-gray-400">
                        يدعم: JPG, PNG, GIF (حتى 10 ميجابايت)
                    </p>
                    <input type="file" id="imageFile" accept="image/*" class="hidden">
                </div>
                <div id="imagePreview" class="hidden">
                    <img id="previewImg" class="max-w-full h-64 object-contain mx-auto rounded-lg">
                    <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">الصورة جاهزة للتحليل</p>
                </div>
            </div>

            <button id="analyzeBtn" class="w-full mt-4 bg-gradient-to-r from-primary to-purple-600 text-white font-bold py-3 px-6 rounded-lg hover:shadow-lg transform hover:scale-105 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                <i class="fas fa-search mr-2"></i>
                بدء التحليل المتقدم
            </button>

            <p id="opencvStatus" class="mt-3 text-sm text-gray-500 dark:text-gray-400">جارِ تحميل OpenCV.js...</p>
        </div>

        <!-- Progress Section -->
        <div id="progressSection" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
            <h3 class="text-xl font-bold mb-4 flex items-center">
                <i class="fas fa-cog fa-spin mr-3 text-primary"></i>
                جاري التحليل...
            </h3>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4 mb-4">
                <div id="progressBar" class="progress-container h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
            </div>
            <p id="progressText" class="text-center text-gray-600 dark:text-gray-400 font-medium">0% - جاري التحضير...</p>
        </div>

        <!-- Results Section -->
        <div id="resultSection" class="hidden">
            <!-- Overall Score -->
            <div id="overallScore" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-4 flex items-center">
                    <i class="fas fa-chart-line mr-3 text-primary"></i>
                    النتيجة الإجمالية
                </h2>
                <div id="scoreDisplay" class="text-center p-6 rounded-lg text-white font-bold text-3xl">
                    <!-- Score will be inserted here -->
                </div>
                <div id="scoreInterpretation" class="mt-4 p-4 rounded-lg">
                    <!-- Interpretation will be inserted here -->
                </div>
            </div>

            <!-- Detailed Analysis -->
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-bold mb-6 flex items-center">
                    <i class="fas fa-microscope mr-3 text-primary"></i>
                    تحليل مفصل للمقاييس
                </h2>
                <div id="detailedMetrics" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Metrics will be inserted here -->
                </div>
            </div>

            <!-- Visual Comparison -->
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6">
                <h2 class="text-2xl font-bold mb-6 flex items-center">
                    <i class="fas fa-eye mr-3 text-primary"></i>
                    المقارنة البصرية والفروقات
                </h2>
                <div id="visualComparison"></div>
            </div>
        </div>
    </div>

    <!-- Hidden area used for creating canvases for OpenCV.imshow and conversions -->
    <div id="internalCanvases"></div>

    <!-- OpenCV.js -->
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

    <script>
    // ---------- OpenCV init ----------
    let cvReady = false;
    const opencvStatus = document.getElementById('opencvStatus');
    // onRuntimeInitialized may be called after the script loads
    function waitForCV() {
        if (typeof cv !== 'undefined' && cv && cv['onRuntimeInitialized']) {
            cv['onRuntimeInitialized'] = () => {
                cvReady = true;
                opencvStatus.textContent = 'OpenCV جاهز للعمل داخل المتصفح.';
            };
        } else {
            // fallback: poll until cv exists
            const t = setInterval(() => {
                if (typeof cv !== 'undefined' && cv && cv['onRuntimeInitialized']) {
                    clearInterval(t);
                    cv['onRuntimeInitialized'] = () => {
                        cvReady = true;
                        opencvStatus.textContent = 'OpenCV جاهز للعمل داخل المتصفح.';
                    };
                }
            }, 200);
        }
    }
    waitForCV();

    // ---------- Existing UI handlers ----------
    const uploadArea = document.getElementById('uploadArea');
    const imageFile = document.getElementById('imageFile');
    const uploadContent = document.getElementById('uploadContent');
    const imagePreview = document.getElementById('imagePreview');
    const previewImg = document.getElementById('previewImg');
    const analyzeBtn = document.getElementById('analyzeBtn');

    uploadArea.addEventListener('click', () => imageFile.click());
    uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => {
        uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleFileSelect(files[0]);
        }
    });

    imageFile.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            handleFileSelect(e.target.files[0]);
        }
    });

    function handleFileSelect(file) {
        if (!file.type.startsWith('image/')) {
            showCustomAlert('يرجى اختيار ملف صورة صحيح');
            return;
        }
        if (file.size > 10 * 1024 * 1024) {
            showCustomAlert('حجم الملف كبير جداً (حد أقصى 10 ميجابايت)');
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            previewImg.src = e.target.result;
            uploadContent.classList.add('hidden');
            imagePreview.classList.remove('hidden');
            analyzeBtn.disabled = false;
        };
        reader.readAsDataURL(file);
    }

    analyzeBtn.addEventListener('click', startSingleImageAnalysis);

    // ---------- Utility: load image into canvas ----------
    async function loadImageToCanvas(file) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                // limit maximum size for performance (optional)
                const maxDim = 2000;
                let width = img.width, height = img.height;
                if (Math.max(width, height) > maxDim) {
                    const scale = maxDim / Math.max(width, height);
                    width = Math.round(width * scale);
                    height = Math.round(height * scale);
                }
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                resolve(canvas);
            };
            img.onerror = (err) => reject(err);
            img.src = URL.createObjectURL(file);
        });
    }

    // ---------- Helper: convert cv.Mat to dataURL (via canvas) ----------
    function matToDataURL(mat) {
        // create a canvas, use cv.imshow to draw mat, then toDataURL
        const canvas = document.createElement('canvas');
        canvas.width = mat.cols;
        canvas.height = mat.rows;
        document.getElementById('internalCanvases').appendChild(canvas);
        try {
            cv.imshow(canvas, mat);
            const dataUrl = canvas.toDataURL();
            canvas.remove();
            return dataUrl;
        } catch (e) {
            canvas.remove();
            throw e;
        }
    }

    // ---------- Core: select matching regions from left and right halves ----------
    async function selectMatchingRegionsLeftRight(imageCanvas, patchSize = 180) {
        return new Promise((resolve, reject) => {
            if (!cvReady) return reject(new Error('OpenCV.js لم يُحمّل بعد.'));
            try {
                let src = cv.imread(imageCanvas); // RGBA mat
                if (src.empty()) { src.delete(); return reject(new Error('فشل قراءة الصورة')); }

                const width = src.cols, height = src.rows;
                const halfW = Math.floor(width / 2);

                // ROI left and right (as Mats referencing src)
                const leftR = new cv.Rect(0, 0, halfW, height);
                const rightR = new cv.Rect(halfW, 0, width - halfW, height);
                let left = src.roi(leftR);
                let right = src.roi(rightR);

                // Convert to gray
                let grayL = new cv.Mat();
                let grayR = new cv.Mat();
                cv.cvtColor(left, grayL, cv.COLOR_RGBA2GRAY);
                cv.cvtColor(right, grayR, cv.COLOR_RGBA2GRAY);

                // ORB detector
                let orb = new cv.ORB();
                let kpL = new cv.KeyPointVector();
                let kpR = new cv.KeyPointVector();
                let descL = new cv.Mat();
                let descR = new cv.Mat();
                orb.detectAndCompute(grayL, new cv.Mat(), kpL, descL);
                orb.detectAndCompute(grayR, new cv.Mat(), kpR, descR);

                if (kpL.size() < 1 || kpR.size() < 1) {
                    // cleanup
                    src.delete(); left.delete(); right.delete();
                    grayL.delete(); grayR.delete();
                    orb.delete(); kpL.delete(); kpR.delete();
                    descL.delete(); descR.delete();
                    return reject(new Error('لم يتم العثور على نقاط مميزة كافية في أحد النصفين.'));
                }

                // BFMatcher for Hamming (ORB descriptors)
                let bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                let matches = new cv.DMatchVector();
                bf.match(descL, descR, matches);

                if (matches.size() < 1) {
                    // cleanup
                    src.delete(); left.delete(); right.delete();
                    grayL.delete(); grayR.delete();
                    orb.delete(); kpL.delete(); kpR.delete();
                    descL.delete(); descR.delete();
                    bf.delete(); matches.delete();
                    return reject(new Error('لا توجد مطابقة بين النصف الأيمن واليسار.'));
                }

                // اختر أفضل المطابقات بحسب المسافة: نقلها إلى مصفوفة عادية
                let matchesArray = [];
                for (let i = 0; i < matches.size(); i++) {
                    matchesArray.push(matches.get(i));
                }
                matchesArray.sort((a, b) => a.distance - b.distance);

                // استخدم أفضل match موجود (أول عنصر) لكن تأكد أن النقاط بعيدة عن الحواف
                let chosen = matchesArray[0];
                let kpLeftPt = kpL.get(chosen.queryIdx).pt;   // coords ضمن left
                let kpRightPt = kpR.get(chosen.trainIdx).pt;  // coords ضمن right

                // نحسب مراكز القص داخل صورة المصدر (global coordinates)
                const centerLeftGlobal = { x: kpLeftPt.x, y: kpLeftPt.y };
                const centerRightGlobal = { x: halfW + kpRightPt.x, y: kpRightPt.y };

                // وظيفة لقص مربع حول نقطة (يعالج حالة قرب الحواف)
                function cropSquareAround(srcMat, centerX, centerY, size) {
                    const half = Math.floor(size / 2);
                    // ensure inside bounds
                    const x0 = Math.max(0, Math.min(srcMat.cols - size, Math.round(centerX - half)));
                    const y0 = Math.max(0, Math.min(srcMat.rows - size, Math.round(centerY - half)));
                    const rect = new cv.Rect(x0, y0, Math.min(size, srcMat.cols - x0), Math.min(size, srcMat.rows - y0));
                    return srcMat.roi(rect);
                }

                // استخراج الأجزاء كمات مستقلة
                const regionLeftMat = cropSquareAround(src, centerLeftGlobal.x, centerLeftGlobal.y, patchSize);
                const regionRightMat = cropSquareAround(src, centerRightGlobal.x, centerRightGlobal.y, patchSize);

                // Clone mats (roi is a view, we clone to منع مشاكل التحرير لاحقاً)
                const regionLeft = regionLeftMat.clone();
                const regionRight = regionRightMat.clone();

                // حفظ للعرض (dataURLs) لاحقاً
                const leftURL = matToDataURL(regionLeft);
                const rightURL = matToDataURL(regionRight);

                // Cleanup intermediate mats
                src.delete();
                left.delete(); right.delete();
                grayL.delete(); grayR.delete();
                orb.delete(); kpL.delete(); kpR.delete();
                descL.delete(); descR.delete();
                bf.delete(); matches.delete();
                regionLeftMat.delete(); regionRightMat.delete();

                // نرجع المات النهائية + dataURLs للعرض
                resolve({
                    leftMat: regionLeft,
                    rightMat: regionRight,
                    leftURL,
                    rightURL,
                    matchInfo: {
                        distance: chosen.distance,
                        queryIdx: chosen.queryIdx,
                        trainIdx: chosen.trainIdx
                    }
                });

            } catch (err) {
                reject(err);
            }
        });
    }

    // ---------- LBP computation and comparison ----------
    function computeLBPHist(grayMat) {
        // expects grayMat (CV_8UC1)
        const rows = grayMat.rows, cols = grayMat.cols;
        const data = grayMat.data;
        const hist = new Array(256).fill(0);
        for (let y = 1; y < rows - 1; y++) {
            for (let x = 1; x < cols - 1; x++) {
                const center = data[y * cols + x];
                let code = 0;
                code |= (data[(y - 1) * cols + (x - 1)] > center) << 7;
                code |= (data[(y - 1) * cols + x] > center) << 6;
                code |= (data[(y - 1) * cols + (x + 1)] > center) << 5;
                code |= (data[y * cols + (x + 1)] > center) << 4;
                code |= (data[(y + 1) * cols + (x + 1)] > center) << 3;
                code |= (data[(y + 1) * cols + x] > center) << 2;
                code |= (data[(y + 1) * cols + (x - 1)] > center) << 1;
                code |= (data[y * cols + (x - 1)] > center) << 0;
                hist[code]++;
            }
        }
        const total = hist.reduce((a,b)=>a+b,0) || 1;
        return hist.map(v => v / total);
    }

    function compareLBP(matA, matB) {
        let gA = new cv.Mat(), gB = new cv.Mat();
        cv.cvtColor(matA, gA, cv.COLOR_RGBA2GRAY);
        cv.cvtColor(matB, gB, cv.COLOR_RGBA2GRAY);
        const hA = computeLBPHist(gA);
        const hB = computeLBPHist(gB);
        // compute correlation
        let num = 0, denA = 0, denB = 0;
        for (let i = 0; i < hA.length; i++) {
            num += (hA[i] - 0) * (hB[i] - 0);
            denA += hA[i]*hA[i];
            denB += hB[i]*hB[i];
        }
        const corr = (num / (Math.sqrt(denA*denB) + 1e-9));
        gA.delete(); gB.delete();
        return Math.max(0, Math.min(100, corr * 100));
    }

    // ---------- Histogram (HSV) comparison ----------
    function compareHistograms(matA, matB) {
        let hsvA = new cv.Mat(), hsvB = new cv.Mat();
        cv.cvtColor(matA, hsvA, cv.COLOR_RGBA2HSV);
        cv.cvtColor(matB, hsvB, cv.COLOR_RGBA2HSV);
        const channels = [0,1];
        const histSize = [50, 60];
        const ranges = [0, 180, 0, 256];
        let histA = new cv.Mat(), histB = new cv.Mat();
        cv.calcHist(hsvA, channels, new cv.Mat(), histA, histSize, ranges);
        cv.calcHist(hsvB, channels, new cv.Mat(), histB, histSize, ranges);
        cv.normalize(histA, histA, 0, 1, cv.NORM_MINMAX);
        cv.normalize(histB, histB, 0, 1, cv.NORM_MINMAX);
        const score = cv.compareHist(histA, histB, cv.HISTCMP_CORREL) * 100;
        hsvA.delete(); hsvB.delete(); histA.delete(); histB.delete();
        return Math.max(0, Math.min(100, score));
    }

    // ---------- Edge comparison (Canny) ----------
    function compareEdges(matA, matB) {
        let gA = new cv.Mat(), gB = new cv.Mat();
        cv.cvtColor(matA, gA, cv.COLOR_RGBA2GRAY);
        cv.cvtColor(matB, gB, cv.COLOR_RGBA2GRAY);
        let eA = new cv.Mat(), eB = new cv.Mat();
        cv.Canny(gA, eA, 80, 180);
        cv.Canny(gB, eB, 80, 180);
        let diff = new cv.Mat();
        cv.absdiff(eA, eB, diff);
        const nonZero = cv.countNonZero(diff);
        const total = diff.rows * diff.cols;
        const similarity = Math.max(0, Math.min(100, (1 - nonZero/total) * 100));
        gA.delete(); gB.delete(); eA.delete(); eB.delete(); diff.delete();
        return similarity;
    }

    // ---------- ORB match similarity between two patches ----------
    function compareORB(matA, matB) {
        let grayA = new cv.Mat(), grayB = new cv.Mat();
        cv.cvtColor(matA, grayA, cv.COLOR_RGBA2GRAY);
        cv.cvtColor(matB, grayB, cv.COLOR_RGBA2GRAY);
        let orb = new cv.ORB();
        let kpA = new cv.KeyPointVector(), kpB = new cv.KeyPointVector();
        let dA = new cv.Mat(), dB = new cv.Mat();
        orb.detectAndCompute(grayA, new cv.Mat(), kpA, dA);
        orb.detectAndCompute(grayB, new cv.Mat(), kpB, dB);
        if (kpA.size() === 0 || kpB.size() === 0) {
            grayA.delete(); grayB.delete(); orb.delete(); kpA.delete(); kpB.delete(); dA.delete(); dB.delete();
            return 0;
        }
        let bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
        let matches = new cv.DMatchVector();
        bf.match(dA, dB, matches);
        // score = matches_count / max(kpA,kpB)
        const matchesCount = matches.size();
        const denom = Math.max(kpA.size(), kpB.size(), 1);
        const score = (matchesCount / denom) * 100;
        grayA.delete(); grayB.delete();
        orb.delete(); kpA.delete(); kpB.delete(); dA.delete(); dB.delete();
        bf.delete(); matches.delete();
        return Math.max(0, Math.min(100, score));
    }

    // ---------- Pixel-level diff ----------
    function simplePixelDiff(matA, matB) {
        // convert to gray and compute avg absolute difference
        let gA = new cv.Mat(), gB = new cv.Mat();
        cv.cvtColor(matA, gA, cv.COLOR_RGBA2GRAY);
        cv.cvtColor(matB, gB, cv.COLOR_RGBA2GRAY);
        let diff = new cv.Mat();
        cv.absdiff(gA, gB, diff);
        const sum = cv.sumElems(diff).w; // sum of grayscale differences
        const avg = sum / (diff.rows * diff.cols);
        gA.delete(); gB.delete(); diff.delete();
        // map avg (0..255) -> similarity (100..0)
        return Math.max(0, Math.min(100, 100 - (avg / 255) * 100));
    }

    // ---------- Create diff image (red highlights) and heatmap ----------
    function createDiffImageFromMats(matA, matB) {
        // convert to canvas-friendly visuals: show red where absdiff > threshold
        const canvasA = document.createElement('canvas');
        const canvasB = document.createElement('canvas');
        canvasA.width = matA.cols; canvasA.height = matA.rows;
        canvasB.width = matB.cols; canvasB.height = matB.rows;
        document.getElementById('internalCanvases').appendChild(canvasA);
        document.getElementById('internalCanvases').appendChild(canvasB);
        cv.imshow(canvasA, matA);
        cv.imshow(canvasB, matB);
        const ctxA = canvasA.getContext('2d');
        const ctxB = canvasB.getContext('2d');
        const imgA = ctxA.getImageData(0,0,canvasA.width, canvasA.height);
        const imgB = ctxB.getImageData(0,0,canvasB.width, canvasB.height);

        const outCanvas = document.createElement('canvas');
        outCanvas.width = canvasA.width; outCanvas.height = canvasA.height;
        const outCtx = outCanvas.getContext('2d');
        const out = outCtx.createImageData(outCanvas.width, outCanvas.height);

        for (let i = 0; i < imgA.data.length; i += 4) {
            const rA = imgA.data[i], gA_ = imgA.data[i+1], bA = imgA.data[i+2];
            const rB = imgB.data[i], gB_ = imgB.data[i+1], bB = imgB.data[i+2];
            const grayA = (rA+gA_+bA)/3;
            const grayB = (rB+gB_+bB)/3;
            const diff = Math.abs(grayA - grayB);
            if (diff > 20) {
                out.data[i] = 255; out.data[i+1] = 0; out.data[i+2] = 0; out.data[i+3] = 255;
            } else {
                const intensity = Math.min(255, Math.round((grayA+grayB)/2));
                out.data[i] = intensity; out.data[i+1] = intensity; out.data[i+2] = intensity; out.data[i+3] = 255;
            }
        }
        outCtx.putImageData(out, 0, 0);

        // heatmap: blue->green->red according to normalized diff
        const heatCanvas = document.createElement('canvas');
        heatCanvas.width = canvasA.width; heatCanvas.height = canvasA.height;
        const heatCtx = heatCanvas.getContext('2d');
        const heat = heatCtx.createImageData(heatCanvas.width, heatCanvas.height);
        for (let i = 0; i < imgA.data.length; i += 4) {
            const rA = imgA.data[i], gA_ = imgA.data[i+1], bA = imgA.data[i+2];
            const rB = imgB.data[i], gB_ = imgB.data[i+1], bB = imgB.data[i+2];
            const grayA = (rA+gA_+bA)/3;
            const grayB = (rB+gB_+bB)/3;
            const dnorm = Math.min(1, Math.abs(grayA - grayB)/255);
            // map to color
            let R=0,G=0,B=0;
            if (dnorm < 0.33) { B = Math.round(255 * (1 - dnorm/0.33)); G = Math.round(255 * (dnorm/0.33)); }
            else if (dnorm < 0.66) { G = Math.round(255 * (1 - (dnorm-0.33)/0.33)); R = Math.round(255 * ((dnorm-0.33)/0.33)); }
            else { R = Math.round(255 * (dnorm - 0.66)/0.34); }
            heat.data[i] = R; heat.data[i+1] = G; heat.data[i+2] = B; heat.data[i+3] = Math.round(180*dnorm + 50);
        }
        heatCtx.putImageData(heat, 0, 0);

        // cleanup canvases
        canvasA.remove(); canvasB.remove();

        return {
            diffDataURL: outCanvas.toDataURL(),
            heatmapDataURL: heatCanvas.toDataURL()
        };
    }

    // ---------- Main analysis flow ----------
    async function startSingleImageAnalysis() {
        const file = imageFile.files[0];
        if (!file) {
            showCustomAlert('يرجى اختيار صورة أولاً');
            return;
        }
        if (!cvReady) {
            showCustomAlert('التحليل غير جاهز — جارٍ تحميل OpenCV. انتظر قليلاً ثم حاول مرة أخرى.');
            return;
        }

        document.getElementById('progressSection').classList.remove('hidden');
        document.getElementById('resultSection').classList.add('hidden');
        updateProgress(5, 'تحميل الصورة وتجهيزها...');

        try {
            const canvas = await loadImageToCanvas(file);

            updateProgress(15, 'تحديد مناطق متطابقة هندسياً (يسار مقابل يمين)...');
            const selection = await selectMatchingRegionsLeftRight(canvas, 180); // patch size adjustable
            updateProgress(30, 'المناطق المحددة — إجراء التحليلات المتقدمة...');

            const leftMat = selection.leftMat;
            const rightMat = selection.rightMat;
            const leftURL = selection.leftURL;
            const rightURL = selection.rightURL;

            // Compute metrics
            updateProgress(40, 'مقارنة النقاط المميزة (ORB)...');
            const orbScore = compareORB(leftMat, rightMat);

            updateProgress(55, 'تحليل النسيج (LBP)...');
            const lbpScore = compareLBP(leftMat, rightMat);

            updateProgress(68, 'مقارنة توزيعات الألوان (Histogram HSV)...');
            const histScore = compareHistograms(leftMat, rightMat);

            updateProgress(78, 'مقارنة الحواف (Canny)...');
            const edgeScore = compareEdges(leftMat, rightMat);

            updateProgress(86, 'مقارنة بكسلات نهائية وإنشاء صور الفروقات...');
            const pixelScore = simplePixelDiff(leftMat, rightMat);

            const imgs = createDiffImageFromMats(leftMat, rightMat);

            // Weights (يمكن تعديلها لاحقاً)
            const weights = {
                orb: 0.25,
                lbp: 0.20,
                hist: 0.20,
                edge: 0.20,
                pixel: 0.15
            };

            const finalScore = Math.max(0, Math.min(100,
                orbScore*weights.orb +
                lbpScore*weights.lbp +
                histScore*weights.hist +
                edgeScore*weights.edge +
                pixelScore*weights.pixel
            ));

            updateProgress(100, `تم الانتهاء - النتيجة: ${finalScore.toFixed(1)}%`);

            // Prepare results object
            const results = {
                score: finalScore,
                metrics: {
                    orb: orbScore,
                    lbp: lbpScore,
                    histogram: histScore,
                    edge: edgeScore,
                    pixel: pixelScore
                },
                images: {
                    left: leftURL,
                    right: rightURL,
                    diff: imgs.diffDataURL,
                    heatmap: imgs.heatmapDataURL
                }
            };

            // show after brief pause for UX
            setTimeout(() => displayResults(results), 700);

            // cleanup mats (we created leftMat & rightMat as clones earlier)
            leftMat.delete(); rightMat.delete();

        } catch (err) {
            console.error(err);
            showCustomAlert('حدث خطأ أثناء التحليل: ' + (err.message || err));
            updateProgress(0, 'خطأ أثناء التحليل');
        }
    }

    // ---------- UI helpers ----------
    function updateProgress(percentage, text) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        progressBar.style.width = percentage + '%';
        progressText.textContent = `${percentage}% - ${text}`;
    }

    function displayResults(results) {
        document.getElementById('progressSection').classList.add('hidden');
        document.getElementById('resultSection').classList.remove('hidden');

        const { score, metrics, images } = results;

        // Display overall score
        const scoreDisplay = document.getElementById('scoreDisplay');
        const scoreInterpretation = document.getElementById('scoreInterpretation');

        let scoreClass, interpretation, icon;
        if (score >= 75) {
            scoreClass = 'result-excellent';
            interpretation = '✅ المستند يبدو أصلياً أو متطابقاً بشكل كبير عبر الجانبين. لا توجد دلائل واضحة على التزوير.';
            icon = 'fas fa-check-circle';
        } else if (score >= 50) {
            scoreClass = 'result-good';
            interpretation = '⚠️ توجد اختلافات ملحوظة بعض الشيء. يُنصح بفحص إضافي وربما مقارنة مع مرجع خارجي.';
            icon = 'fas fa-exclamation-triangle';
        } else {
            scoreClass = 'result-poor';
            interpretation = '🚨 اختلافات كبيرة بين جانبي المستند — احتمال وجود تلاعب أو اختلافات مادية.';
            icon = 'fas fa-times-circle';
        }

        scoreDisplay.className = `text-center p-6 rounded-lg text-white font-bold text-3xl ${scoreClass}`;
        scoreDisplay.innerHTML = `
            <i class="${icon} mr-3"></i>
            ${score.toFixed(1)}%
        `;

        scoreInterpretation.className = `mt-4 p-4 rounded-lg border-r-4 ${score >= 75 ? 'bg-green-50 dark:bg-green-900/20 border-green-500' : score >= 50 ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-500' : 'bg-red-50 dark:bg-red-900/20 border-red-500'}`;
        scoreInterpretation.innerHTML = interpretation;

        // Display detailed metrics
        const metricsContainer = document.getElementById('detailedMetrics');
        const metricLabels = {
            orb: { name: 'مطابقة الميزات (ORB)', icon: 'fas fa-shapes' },
            lbp: { name: 'تحليل النسيج (LBP)', icon: 'fas fa-th-large' },
            histogram: { name: 'مقارنة الألوان (Histogram)', icon: 'fas fa-palette' },
            edge: { name: 'مقارنة الحواف (Canny)', icon: 'fas fa-vector-square' },
            pixel: { name: 'مقارنة البكسلات', icon: 'fas fa-th' }
        };

        metricsContainer.innerHTML = Object.entries(metrics).map(([key, value]) => {
            const label = metricLabels[key];
            const percentage = value.toFixed(1);
            const colorClass = value >= 75 ? 'text-green-600' : value >= 50 ? 'text-yellow-600' : 'text-red-600';
            
            return `
                <div class="metric-card bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center">
                            <i class="${label.icon} text-primary mr-2"></i>
                            <span class="font-medium">${label.name}</span>
                        </div>
                        <span class="font-bold ${colorClass}">${percentage}%</span>
                    </div>
                    <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2">
                        <div class="bg-gradient-to-r from-primary to-purple-600 h-2 rounded-full transition-all duration-1000" style="width: ${value}%"></div>
                    </div>
                </div>
            `;
        }).join('');

        // Display visual comparison including the two patches + diff + heatmap
        const visualComparison = document.getElementById('visualComparison');
        visualComparison.innerHTML = `
            <div class="comparison-images">
                <div class="image-preview">
                    <img src="${images.left}" alt="المنطقة اليسرى (جزء)">
                    <div class="image-label">المنطقة من النصف الأيسر</div>
                </div>
                <div class="image-preview">
                    <img src="${images.right}" alt="المنطقة اليمنى (جزء)">
                    <div class="image-label">المنطقة من النصف الأيمن</div>
                </div>
                <div class="image-preview">
                    <img src="${images.diff}" alt="صورة الفروقات">
                    <div class="image-label">الفروقات (أحمر = اختلاف واضح)</div>
                </div>
            </div>
            <div class="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-700">
                <h4 class="font-bold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                    <i class="fas fa-info-circle mr-2"></i>
                    تفسير النتائج البصرية
                </h4>
                <ul class="text-blue-700 dark:text-blue-300 text-sm space-y-1">
                    <li>• <strong>المنطقتان المختارتان:</strong> تم اختيارهما بناءً على نقاط ميزة متطابقة هندسياً (ORB) من النصف الأيسر واليمين.</li>
                    <li>• <strong>المناطق الحمراء:</strong> تشير إلى اختلافات واضحة في الإضاءة/النسيج/البنية.</li>
                    <li>• <strong>الاختلافات الطفيفة:</strong> قد تنتج عن ضوضاء ضغط الصورة أو مسح مختلفة الزاوية — نأخذ ذلك بعين الاعتبار في المقارنات.</li>
                </ul>
            </div>
        `;

        document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
    }

    function showCustomAlert(message) {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        modal.innerHTML = `
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                <div class="flex items-center mb-4">
                    <i class="fas fa-exclamation-triangle text-yellow-500 text-xl mr-3"></i>
                    <h3 class="font-bold text-lg">تنبيه</h3>
                </div>
                <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                <div class="flex justify-end">
                    <button class="px-4 py-2 bg-primary text-white hover:bg-purple-600 rounded transition-colors" onclick="this.closest('.fixed').remove()">حسناً</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    </script>
</body>
</html>

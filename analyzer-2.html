<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>كاشف المستندات المزورة - إصدار محسّن</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://kit.fontawesome.com/4b9ba14b0f.js" crossorigin="anonymous"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: { colors: { primary: '#5D5CDE' } }
      }
    }
  </script>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    .upload-area { border: 2px dashed #d1d5db; transition: all 0.3s ease; }
    .upload-area:hover { border-color: #5D5CDE; background-color: rgba(93, 92, 222, 0.05);}
    .upload-area.dragover { border-color: #5D5CDE; background-color: rgba(93, 92, 222, 0.1);}
    .analysis-card { background: linear-gradient(135deg, rgba(93, 92, 222, 0.1) 0%, rgba(147, 51, 234, 0.1) 100%); border: 1px solid rgba(93, 92, 222, 0.2);}
    .progress-container { background: linear-gradient(90deg, #5D5CDE 0%, #9333EA 100%); }
    .result-excellent { background: linear-gradient(135deg, #10B981 0%, #059669 100%); }
    .result-good { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); }
    .result-poor { background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); }
    .metric-card { transition: all 0.3s ease; border: 1px solid rgba(93, 92, 222, 0.1); }
    .metric-card:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(93, 92, 222, 0.15); }
    .comparison-images { display: grid; grid-template-columns: repeat(4,1fr); gap: 1rem; margin-top: 1rem; }
    .image-preview { border: 2px solid #e5e7eb; border-radius: 8px; overflow: hidden; position: relative; }
    .image-preview img { width: 100%; height: auto; display: block; }
    .image-label { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 0.5rem; text-align: center; font-size: 0.875rem; }
  </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
  <div class="container mx-auto px-4 py-8 max-w-7xl">
    <!-- Header -->
    <div class="text-center mb-8">
      <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-primary to-purple-600 bg-clip-text text-transparent">
        <i class="fas fa-shield-alt mr-3"></i>
        كاشف المستندات المزورة
      </h1>
      <p class="text-gray-600 dark:text-gray-400 text-lg">
        مقارنة مرجعية وفحص متقدم لاكتشاف التلاعب اعتماداً على عدة مقاييس بصرية
      </p>
    </div>

    <!-- Controls -->
    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
      <h2 class="text-2xl font-bold mb-4 flex items-center">
        <i class="fas fa-sliders-h mr-3 text-primary"></i>
        إعدادات التحليل
      </h2>
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label class="block text-sm mb-2 text-gray-600 dark:text-gray-300">نوع العينة</label>
          <select id="analysisType" class="w-full rounded-lg border-gray-300 dark:border-gray-700 dark:bg-gray-700 dark:text-white">
            <option value="document">مستند</option>
            <option value="currency">عملة</option>
            <option value="stamp">ختم</option>
            <option value="photo">صورة</option>
          </select>
        </div>
        <div class="flex items-center">
          <input id="autoAlign" type="checkbox" class="mr-2">
          <label for="autoAlign" class="text-sm text-gray-700 dark:text-gray-300">محاذاة تلقائية بسيطة (ترجمة فقط)</label>
        </div>
        <div class="text-sm text-gray-500 dark:text-gray-400">
          ملاحظة: للحصول على نتائج أدق، حاول استخدام صور مرجعية مماثلة في الإضاءة والدقة، ويفضل مسح ضوئي عالي الدقة.
        </div>
      </div>
    </div>

    <!-- Upload Section -->
    <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
      <h2 class="text-2xl font-bold mb-4 flex items-center">
        <i class="fas fa-upload mr-3 text-primary"></i>
        رفع الصور للمقارنة
      </h2>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <!-- Reference -->
        <div>
          <h3 class="font-semibold mb-2">الصورة المرجعية (أصلية متوقعة)</h3>
          <div id="uploadAreaRef" class="upload-area rounded-lg p-8 text-center cursor-pointer bg-gray-50 dark:bg-gray-700">
            <div id="uploadContentRef">
              <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
              <p class="text-lg font-medium text-gray-600 dark:text-gray-300 mb-2">اسحب الصورة هنا أو انقر للاختيار</p>
              <p class="text-sm text-gray-500 dark:text-gray-400">يدعم: JPG, PNG, GIF (حتى 10 ميجابايت)</p>
              <input type="file" id="refImageFile" accept="image/*" class="hidden">
            </div>
            <div id="imagePreviewRef" class="hidden">
              <img id="previewImgRef" class="max-w-full h-64 object-contain mx-auto rounded-lg">
              <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">الصورة جاهزة</p>
            </div>
          </div>
        </div>

        <!-- Suspect -->
        <div>
          <h3 class="font-semibold mb-2">الصورة قيد الفحص</h3>
          <div id="uploadAreaSus" class="upload-area rounded-lg p-8 text-center cursor-pointer bg-gray-50 dark:bg-gray-700">
            <div id="uploadContentSus">
              <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
              <p class="text-lg font-medium text-gray-600 dark:text-gray-300 mb-2">اسحب الصورة هنا أو انقر للاختيار</p>
              <p class="text-sm text-gray-500 dark:text-gray-400">يدعم: JPG, PNG, GIF (حتى 10 ميجابايت)</p>
              <input type="file" id="susImageFile" accept="image/*" class="hidden">
            </div>
            <div id="imagePreviewSus" class="hidden">
              <img id="previewImgSus" class="max-w-full h-64 object-contain mx-auto rounded-lg">
              <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">الصورة جاهزة</p>
            </div>
          </div>
        </div>
      </div>

      <button id="analyzeBtn" class="w-full mt-6 bg-gradient-to-r from-primary to-purple-600 text-white font-bold py-3 px-6 rounded-lg hover:shadow-lg transform hover:scale-105 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
        <i class="fas fa-search mr-2"></i>
        بدء التحليل المتقدم
      </button>
    </div>

    <!-- Progress -->
    <div id="progressSection" class="hidden bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
      <h3 class="text-xl font-bold mb-4 flex items-center">
        <i class="fas fa-cog fa-spin mr-3 text-primary"></i>
        جاري التحليل...
      </h3>
      <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4 mb-4">
        <div id="progressBar" class="progress-container h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
      </div>
      <p id="progressText" class="text-center text-gray-600 dark:text-gray-400 font-medium">0% - جاري التحضير...</p>
    </div>

    <!-- Results -->
    <div id="resultSection" class="hidden">
      <!-- Overall Score -->
      <div id="overallScore" class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
        <h2 class="text-2xl font-bold mb-4 flex items-center">
          <i class="fas fa-chart-line mr-3 text-primary"></i>
          النتيجة الإجمالية
        </h2>
        <div id="scoreDisplay" class="text-center p-6 rounded-lg text-white font-bold text-3xl"></div>
        <div id="scoreInterpretation" class="mt-4 p-4 rounded-lg text-sm"></div>
      </div>

      <!-- Detailed -->
      <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 mb-8">
        <h2 class="text-2xl font-bold mb-6 flex items-center">
          <i class="fas fa-microscope mr-3 text-primary"></i>
          تحليل مفصل للمقاييس
        </h2>
        <div id="detailedMetrics" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
      </div>

      <!-- Visual Comparison -->
      <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6">
        <h2 class="text-2xl font-bold mb-6 flex items-center">
          <i class="fas fa-eye mr-3 text-primary"></i>
          المقارنة البصرية والفروقات
        </h2>
        <div id="visualComparison"></div>
      </div>
    </div>
  </div>

  <script>
    // Dark mode
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.documentElement.classList.add('dark');
    }
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
      document.documentElement.classList.toggle('dark', e.matches);
    });

    // Elements
    const analyzeBtn = document.getElementById('analyzeBtn');
    const refFileInput = document.getElementById('refImageFile');
    const susFileInput = document.getElementById('susImageFile');
    const uploadAreaRef = document.getElementById('uploadAreaRef');
    const uploadAreaSus = document.getElementById('uploadAreaSus');
    const uploadContentRef = document.getElementById('uploadContentRef');
    const uploadContentSus = document.getElementById('uploadContentSus');
    const imagePreviewRef = document.getElementById('imagePreviewRef');
    const imagePreviewSus = document.getElementById('imagePreviewSus');
    const previewImgRef = document.getElementById('previewImgRef');
    const previewImgSus = document.getElementById('previewImgSus');

    const analysisTypeSelect = document.getElementById('analysisType');
    const autoAlignCheckbox = document.getElementById('autoAlign');

    // Upload handlers
    function setupUpload(area, input, previewContainer, previewImg) {
      area.addEventListener('click', () => input.click());
      area.addEventListener('dragover', e => { e.preventDefault(); area.classList.add('dragover'); });
      area.addEventListener('dragleave', () => area.classList.remove('dragover'));
      area.addEventListener('drop', e => {
        e.preventDefault();
        area.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) handleFileSelect(files[0], input, previewContainer, previewImg);
      });
      input.addEventListener('change', e => {
        if (e.target.files.length > 0) handleFileSelect(e.target.files[0], input, previewContainer, previewImg);
      });
    }
    setupUpload(uploadAreaRef, refFileInput, imagePreviewRef, previewImgRef);
    setupUpload(uploadAreaSus, susFileInput, imagePreviewSus, previewImgSus);

    function handleFileSelect(file, input, previewContainer, previewImg) {
      if (!file.type.startsWith('image/')) return showCustomAlert('يرجى اختيار ملف صورة صحيح');
      if (file.size > 10 * 1024 * 1024) return showCustomAlert('حجم الملف كبير جداً (حد أقصى 10 ميجابايت)');
      const reader = new FileReader();
      reader.onload = e => {
        previewImg.src = e.target.result;
        if (input === refFileInput) { uploadContentRef.classList.add('hidden'); imagePreviewRef.classList.remove('hidden'); }
        else { uploadContentSus.classList.add('hidden'); imagePreviewSus.classList.remove('hidden'); }
        analyzeBtn.disabled = !(refFileInput.files.length && susFileInput.files.length);
      };
      reader.readAsDataURL(file);
    }

    analyzeBtn.addEventListener('click', startAnalysis);

    // Progress
    function updateProgress(p, text) {
      const bar = document.getElementById('progressBar');
      const txt = document.getElementById('progressText');
      bar.style.width = p + '%';
      txt.textContent = `${p}% - ${text}`;
    }

    // Utilities: canvas and image helpers
    async function loadFileToCanvas(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const c = document.createElement('canvas');
          const ctx = c.getContext('2d');
          c.width = img.width; c.height = img.height;
          ctx.drawImage(img, 0, 0);
          resolve(c);
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function resizeCanvas(srcCanvas, maxWidth = 1024) {
      const ratio = srcCanvas.width > maxWidth ? maxWidth / srcCanvas.width : 1;
      const w = Math.round(srcCanvas.width * ratio);
      const h = Math.round(srcCanvas.height * ratio);
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(srcCanvas, 0, 0, w, h);
      return c;
    }

    function toGrayscaleCanvas(canvas) {
      const c = document.createElement('canvas');
      c.width = canvas.width; c.height = canvas.height;
      const ctx = c.getContext('2d');
      ctx.drawImage(canvas, 0, 0);
      const img = ctx.getImageData(0, 0, c.width, c.height);
      const d = img.data;
      for (let i = 0; i < d.length; i += 4) {
        const gray = 0.299 * d[i] + 0.587 * d[i+1] + 0.114 * d[i+2];
        d[i] = d[i+1] = d[i+2] = gray;
      }
      ctx.putImageData(img, 0, 0);
      return c;
    }

    function getImageData(canvas) {
      const ctx = canvas.getContext('2d');
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function cropToCommonArea(refCanvas, susCanvas, dx, dy) {
      // dx, dy are offset to shift suspect relative to ref (sus(x+dx,y+dy) ≈ ref(x,y))
      const x0 = Math.max(0, dx);
      const y0 = Math.max(0, dy);
      const x1 = Math.max(0, -dx);
      const y1 = Math.max(0, -dy);
      const w = Math.min(refCanvas.width - x0, susCanvas.width - x1);
      const h = Math.min(refCanvas.height - y0, susCanvas.height - y1);
      if (w <= 0 || h <= 0) return null;

      const refC = document.createElement('canvas');
      refC.width = w; refC.height = h;
      const susC = document.createElement('canvas');
      susC.width = w; susC.height = h;

      refC.getContext('2d').drawImage(refCanvas, x0, y0, w, h, 0, 0, w, h);
      susC.getContext('2d').drawImage(susCanvas, x1, y1, w, h, 0, 0, w, h);
      return [refC, susC];
    }

    // Simple translation alignment via NCC on downsampled grayscale
    function estimateTranslationByNCC(refGray, susGray, searchRadius = 32) {
      // Downsample for speed
      const targetW = 256;
      const scale = targetW / refGray.width;
      function downsample(grayCanvas) {
        const c = document.createElement('canvas');
        c.width = targetW;
        c.height = Math.round(grayCanvas.height * scale);
        c.getContext('2d').drawImage(grayCanvas, 0, 0, c.width, c.height);
        return c;
      }
      const A = downsample(refGray);
      const B = downsample(susGray);
      const w = Math.min(A.width, B.width);
      const h = Math.min(A.height, B.height);
      const Ad = A.getContext('2d').getImageData(0, 0, w, h).data;
      const BdFull = B.getContext('2d').getImageData(0, 0, B.width, B.height).data;

      function getGrayAt(d, x, y, width) { const i = (y * width + x) * 4; return d[i]; }

      let best = { score: -Infinity, dx: 0, dy: 0 };
      const maxDx = Math.min(searchRadius, B.width - w);
      const maxDy = Math.min(searchRadius, B.height - h);

      // Precompute mean/std for A
      let sumA = 0, sumA2 = 0, N = w * h;
      for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) { const v = getGrayAt(Ad, x, y, w); sumA += v; sumA2 += v*v; }
      const meanA = sumA / N; const stdA = Math.sqrt(Math.max(1e-8, sumA2/N - meanA*meanA));

      for (let dy = -maxDy; dy <= maxDy; dy++) {
        for (let dx = -maxDx; dx <= maxDx; dx++) {
          let sumB = 0, sumB2 = 0, sumAB = 0;
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const a = getGrayAt(Ad, x, y, w);
              const bx = x + dx, by = y + dy;
              if (bx < 0 || by < 0 || bx >= B.width || by >= B.height) continue;
              const b = getGrayAt(BdFull, bx, by, B.width);
              sumB += b; sumB2 += b*b; sumAB += a*b;
            }
          }
          const meanB = sumB / N;
          const stdB = Math.sqrt(Math.max(1e-8, sumB2/N - meanB*meanB));
          const cov = sumAB / N - meanA*meanB;
          const ncc = cov / (stdA * stdB + 1e-8);
          if (ncc > best.score) best = { score: ncc, dx, dy };
        }
      }
      // Upscale offsets to original size
      const invScale = 1/scale;
      return { dx: Math.round(best.dx * invScale), dy: Math.round(best.dy * invScale) };
    }

    // Metrics
    function computeSSIM(canvas1, canvas2) {
      // Global SSIM (تقريب سريع)
      const w = canvas1.width, h = canvas1.height;
      const d1 = canvas1.getContext('2d').getImageData(0,0,w,h).data;
      const d2 = canvas2.getContext('2d').getImageData(0,0,w,h).data;

      let sumX=0, sumY=0, sumX2=0, sumY2=0, sumXY=0;
      const C1 = Math.pow(0.01*255, 2);
      const C2 = Math.pow(0.03*255, 2);

      for (let i=0; i<d1.length; i+=4) {
        const x = (d1[i] + d1[i+1] + d1[i+2]) / 3;
        const y = (d2[i] + d2[i+1] + d2[i+2]) / 3;
        sumX += x; sumY += y;
        sumX2 += x*x; sumY2 += y*y;
        sumXY += x*y;
      }
      const N = d1.length/4;
      const muX = sumX / N;
      const muY = sumY / N;
      const sigmaX2 = sumX2/N - muX*muX;
      const sigmaY2 = sumY2/N - muY*muY;
      const sigmaXY = sumXY/N - muX*muY;

      const numerator = (2*muX*muY + C1) * (2*sigmaXY + C2);
      const denominator = (muX*muX + muY*muY + C1) * (sigmaX2 + sigmaY2 + C2);
      const ssim = Math.max(0, Math.min(1, numerator / (denominator + 1e-8)));
      return ssim * 100;
    }

    function colorHistogramSimilarity(canvas1, canvas2, bins=32) {
      const makeHist = (c) => {
        const d = c.getContext('2d').getImageData(0,0,c.width,c.height).data;
        const hr = new Array(bins).fill(0), hg = new Array(bins).fill(0), hb = new Array(bins).fill(0);
        const bin = v => Math.min(bins-1, Math.floor(v / (256/bins)));
        for (let i=0;i<d.length;i+=4) { hr[bin(d[i])]++; hg[bin(d[i+1])]++; hb[bin(d[i+2])]++; }
        const norm = arr => { const s = arr.reduce((a,b)=>a+b,0) || 1; return arr.map(x=>x/s); };
        return { r: norm(hr), g: norm(hg), b: norm(hb) };
      };
      const H1 = makeHist(canvas1), H2 = makeHist(canvas2);
      const l1 = (a,b) => a.reduce((s, v, i)=> s + Math.abs(v - b[i]), 0);
      const dR = l1(H1.r, H2.r), dG = l1(H1.g, H2.g), dB = l1(H1.b, H2.b);
      const dist = (dR + dG + dB) / 3; // 0..2
      const sim = Math.max(0, 1 - dist/2); // map to 0..1
      return sim * 100;
    }

    function sobelEdgeStrength(canvas) {
      const w = canvas.width, h = canvas.height;
      const ctx = canvas.getContext('2d');
      const img = ctx.getImageData(0,0,w,h);
      const d = img.data;
      let sum = 0;
      function grayAt(x,y){ const i=(y*w+x)*4; return d[i]; }
      for (let y=1;y<h-1;y++){
        for (let x=1;x<w-1;x++){
          const gx = -grayAt(x-1,y-1) + grayAt(x+1,y-1)
                   - 2*grayAt(x-1,y)   + 2*grayAt(x+1,y)
                   - grayAt(x-1,y+1)   + grayAt(x+1,y+1);
          const gy = -grayAt(x-1,y-1) - 2*grayAt(x,y-1) - grayAt(x+1,y-1)
                   + grayAt(x-1,y+1) + 2*grayAt(x,y+1) + grayAt(x+1,y+1);
          sum += Math.hypot(gx, gy);
        }
      }
      return sum / ((w-2)*(h-2));
    }

    function analyzeEdgeConsistency(c1, c2) {
      const e1 = sobelEdgeStrength(toGrayscaleCanvas(c1));
      const e2 = sobelEdgeStrength(toGrayscaleCanvas(c2));
      const sim = 1 - Math.abs(e1 - e2) / Math.max(1e-8, Math.max(e1, e2));
      return Math.max(0, Math.min(1, sim)) * 100;
    }

    function noiseLaplacianVar(canvas) {
      const w = canvas.width, h = canvas.height;
      const ctx = canvas.getContext('2d');
      const img = ctx.getImageData(0,0,w,h);
      const d = img.data;
      function grayAt(x,y){ const i=(y*w+x)*4; return d[i]; }
      let vals = [];
      for (let y=1;y<h-1;y++){
        for (let x=1;x<w-1;x++){
          const L = -grayAt(x,y-1) - grayAt(x-1,y) + 4*grayAt(x,y) - grayAt(x+1,y) - grayAt(x,y+1);
          vals.push(L);
        }
      }
      const N = vals.length || 1;
      const mean = vals.reduce((a,b)=>a+b,0) / N;
      const v = vals.reduce((a,b)=>a + (b-mean)*(b-mean), 0) / N;
      return v;
    }

    function analyzeNoiseSimilarity(c1, c2) {
      const n1 = noiseLaplacianVar(toGrayscaleCanvas(c1));
      const n2 = noiseLaplacianVar(toGrayscaleCanvas(c2));
      const sim = 1 - Math.abs(n1 - n2) / Math.max(1e-8, Math.max(n1, n2));
      return Math.max(0, Math.min(1, sim)) * 100;
    }

    function pixelMSEScore(c1, c2) {
      const w = c1.width, h = c1.height;
      const d1 = c1.getContext('2d').getImageData(0,0,w,h).data;
      const d2 = c2.getContext('2d').getImageData(0,0,w,h).data;
      let se = 0;
      for (let i=0;i<d1.length;i+=4){
        const g1 = (d1[i]+d1[i+1]+d1[i+2])/3;
        const g2 = (d2[i]+d2[i+1]+d2[i+2])/3;
        const diff = g1 - g2;
        se += diff*diff;
      }
      const N = d1.length/4;
      const mse = se / N; // 0..(255^2)
      // map: lower is better. A soft mapping:
      const score = Math.max(0, 100 - (mse / (255*255)) * 100 * 4); // heavier penalty
      return score;
    }

    async function recompressToJPEGCanvas(canvas, quality=0.85) {
      return new Promise((resolve) => {
        const url = canvas.toDataURL('image/jpeg', quality);
        const img = new Image();
        img.onload = () => {
          const c = document.createElement('canvas');
          c.width = canvas.width; c.height = canvas.height;
          c.getContext('2d').drawImage(img, 0, 0, c.width, c.height);
          resolve(c);
        };
        img.src = url;
      });
    }

    async function computeELAMaps(refCanvas, susCanvas, scale=10) {
      // ELA residuals for each, plus similarity
      const refJPEG = await recompressToJPEGCanvas(refCanvas, 0.85);
      const susJPEG = await recompressToJPEGCanvas(susCanvas, 0.85);

      function makeResidual(orig, comp) {
        const w = orig.width, h = orig.height;
        const out = document.createElement('canvas'); out.width=w; out.height=h;
        const dO = orig.getContext('2d').getImageData(0,0,w,h);
        const dC = comp.getContext('2d').getImageData(0,0,w,h);
        const outImg = new ImageData(w, h);
        let sum = 0;
        for (let i=0;i<dO.data.length;i+=4){
          const r = Math.abs(dO.data[i] - dC.data[i]) * scale;
          const g = Math.abs(dO.data[i+1] - dC.data[i+1]) * scale;
          const b = Math.abs(dO.data[i+2] - dC.data[i+2]) * scale;
          outImg.data[i]   = Math.min(255, r);
          outImg.data[i+1] = Math.min(255, g);
          outImg.data[i+2] = Math.min(255, b);
          outImg.data[i+3] = 255;
          sum += (r+g+b)/3;
        }
        out.getContext('2d').putImageData(outImg,0,0);
        const avg = sum / (dO.data.length/4);
        return { residual: out, avg };
      }
      const r1 = makeResidual(refCanvas, refJPEG);
      const r2 = makeResidual(susCanvas, susJPEG);

      // Similarity of ELA residuals (lower difference = higher similarity)
      const elaDiff = Math.abs(r1.avg - r2.avg) / Math.max(1e-6, Math.max(r1.avg, r2.avg));
      const elaSim = Math.max(0, 1 - elaDiff) * 100;
      return { refELA: r1.residual, susELA: r2.residual, elaScore: elaSim };
    }

    function createDiffHeatmap(c1, c2) {
      const w = c1.width, h = c1.height;
      const out = document.createElement('canvas'); out.width = w; out.height = h;
      const d1 = c1.getContext('2d').getImageData(0,0,w,h).data;
      const d2 = c2.getContext('2d').getImageData(0,0,w,h).data;
      const img = new ImageData(w, h);

      for (let i=0;i<d1.length;i+=4){
        const g1 = (d1[i]+d1[i+1]+d1[i+2])/3;
        const g2 = (d2[i]+d2[i+1]+d2[i+2])/3;
        const diff = Math.abs(g1 - g2)/255; // 0..1
        // Blue->Green->Red heatmap
        let r,g,b;
        if (diff < 0.33) {
          r = 0; g = Math.round(255 * (diff/0.33)); b = 255;
        } else if (diff < 0.66) {
          r = Math.round(255 * ( (diff-0.33)/0.33 )); g = 255; b = Math.round(255 * (1 - (diff-0.33)/0.33));
        } else {
          r = 255; g = Math.round(255 * (1 - (diff-0.66)/0.34)); b = 0;
        }
        img.data[i] = r; img.data[i+1] = g; img.data[i+2] = b; img.data[i+3] = 200;
      }
      out.getContext('2d').putImageData(img, 0, 0);
      return out.toDataURL();
    }

    function showCustomAlert(message) {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
          <div class="flex items-center mb-4">
            <i class="fas fa-exclamation-triangle text-yellow-500 text-xl mr-3"></i>
            <h3 class="font-bold text-lg">تنبيه</h3>
          </div>
          <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
          <div class="flex justify-end">
            <button class="px-4 py-2 bg-primary text-white hover:bg-purple-600 rounded transition-colors" onclick="this.closest('.fixed').remove()">حسناً</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }

    async function startAnalysis() {
      const refFile = refFileInput.files[0];
      const susFile = susFileInput.files[0];
      if (!refFile || !susFile) return showCustomAlert('يرجى اختيار الصورتين أولاً');

      document.getElementById('progressSection').classList.remove('hidden');
      document.getElementById('resultSection').classList.add('hidden');
      updateProgress(5, 'تحميل الصور...');

      try {
        // Load + normalize
        let refCanvas = await loadFileToCanvas(refFile);
        let susCanvas = await loadFileToCanvas(susFile);

        updateProgress(15, 'تحجيم الصور...');
        refCanvas = resizeCanvas(refCanvas, 1024);
        susCanvas = resizeCanvas(susCanvas, 1024);

        updateProgress(25, 'تحويل إلى تدرج الرمادي...');
        let refGray = toGrayscaleCanvas(refCanvas);
        let susGray = toGrayscaleCanvas(susCanvas);

        // Optional auto translation alignment
        let dx = 0, dy = 0;
        if (autoAlignCheckbox.checked) {
          updateProgress(35, 'محاذاة تلقائية (ترجمة)...');
          const shift = estimateTranslationByNCC(refGray, susGray, 32);
          dx = shift.dx; dy = shift.dy;
        }

        updateProgress(45, 'تطبيع المساحة المشتركة...');
        const cropped = cropToCommonArea(refCanvas, susCanvas, dx, dy);
        if (!cropped) throw new Error('لم يتم العثور على مساحة مشتركة كافية بعد المحاذاة');
        refCanvas = cropped[0];
        susCanvas = cropped[1];
        refGray = toGrayscaleCanvas(refCanvas);
        susGray = toGrayscaleCanvas(susCanvas);

        updateProgress(55, 'حساب SSIM...');
        const ssimScore = computeSSIM(refCanvas, susCanvas);

        updateProgress(62, 'تحليل المدرجات اللونية...');
        const histScore = colorHistogramSimilarity(refCanvas, susCanvas);

        updateProgress(70, 'تحليل الحواف...');
        const edgeScore = analyzeEdgeConsistency(refCanvas, susCanvas);

        updateProgress(78, 'تقدير الضوضاء...');
        const noiseScore = analyzeNoiseSimilarity(refCanvas, susCanvas);

        updateProgress(86, 'تحليل ELA (ضغط JPEG)...');
        const { refELA, susELA, elaScore } = await computeELAMaps(refCanvas, susCanvas);

        updateProgress(92, 'مقارنة مباشرة للبكسلات...');
        const pixelScore = pixelMSEScore(refCanvas, susCanvas);

        updateProgress(96, 'إنشاء خرائط الفروقات...');
        const heatmapURL = createDiffHeatmap(refCanvas, susCanvas);

        // Weights by analysis type
        const analysisType = analysisTypeSelect.value;
        const weightsMap = {
          document: { ssim:0.25, hist:0.15, edge:0.20, noise:0.15, ela:0.15, pixel:0.10 },
          currency: { ssim:0.25, hist:0.10, edge:0.25, noise:0.15, ela:0.15, pixel:0.10 },
          stamp:    { ssim:0.20, hist:0.15, edge:0.25, noise:0.15, ela:0.15, pixel:0.10 },
          photo:    { ssim:0.30, hist:0.20, edge:0.15, noise:0.10, ela:0.15, pixel:0.10 }
        };
        const w = weightsMap[analysisType] || weightsMap.document;
        const finalScore = ssimScore*w.ssim + histScore*w.hist + edgeScore*w.edge + noiseScore*w.noise + elaScore*w.ela + pixelScore*w.pixel;

        updateProgress(100, `تم الانتهاء - النتيجة: ${finalScore.toFixed(1)}%`);

        setTimeout(() => {
          displayResults({
            score: finalScore,
            metrics: {
              ssim: ssimScore, hist: histScore, edge: edgeScore,
              noise: noiseScore, ela: elaScore, pixel: pixelScore
            },
            images: {
              ref: refCanvas.toDataURL(),
              sus: susCanvas.toDataURL(),
              heatmap: heatmapURL,
              refELA: refELA.toDataURL(),
              susELA: susELA.toDataURL()
            }
          });
        }, 500);

      } catch (err) {
        console.error(err);
        showCustomAlert('حدث خطأ أثناء التحليل: ' + err.message);
      }
    }

    function displayResults({ score, metrics, images }) {
      document.getElementById('progressSection').classList.add('hidden');
      document.getElementById('resultSection').classList.remove('hidden');

      // Score card
      const scoreDisplay = document.getElementById('scoreDisplay');
      const scoreInterpretation = document.getElementById('scoreInterpretation');
      let scoreClass, interp, icon;
      if (score >= 75) {
        scoreClass = 'result-excellent';
        interp = '✅ تطابق قوي مع المرجع. لا دلائل واضحة على التلاعب.';
        icon = 'fas fa-check-circle';
      } else if (score >= 50) {
        scoreClass = 'result-good';
        interp = '⚠️ اختلافات متوسطة. ننصح بالمراجعة اليدوية أو تحليل إضافي.';
        icon = 'fas fa-exclamation-triangle';
      } else {
        scoreClass = 'result-poor';
        interp = '🚨 اختلافات كبيرة. احتمال التلاعب مرتفع، خاصة في المناطق البارزة.';
        icon = 'fas fa-times-circle';
      }
      scoreDisplay.className = `text-center p-6 rounded-lg text-white font-bold text-3xl ${scoreClass}`;
      scoreDisplay.innerHTML = `<i class="${icon} mr-3"></i>${score.toFixed(1)}%`;
      scoreInterpretation.className = `mt-4 p-4 rounded-lg border-r-4 ${score >= 75 ? 'bg-green-50 dark:bg-green-900/20 border-green-500' : score >= 50 ? 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-500' : 'bg-red-50 dark:bg-red-900/20 border-red-500'}`;
      scoreInterpretation.innerHTML = `هذه النتيجة تقديرية وليست بديلاً عن الفحص الجنائي المتخصص. جودة الإدخال (دقة/إضاءة/محاذاة) تؤثر بشكل مباشر على الدقة.`;

      // Metrics list
      const metricsContainer = document.getElementById('detailedMetrics');
      const labels = {
        ssim: { name:'تشابه بنيوي (SSIM)', icon:'fas fa-compress-arrows-alt' },
        hist: { name:'تشابه الألوان (Histogram)', icon:'fas fa-palette' },
        edge: { name:'اتساق الحواف', icon:'fas fa-vector-square' },
        noise:{ name:'اتساق الضوضاء', icon:'fas fa-wave-square' },
        ela:  { name:'تشابه ELA', icon:'fas fa-camera' },
        pixel:{ name:'مقارنة البكسلات (MSE)', icon:'fas fa-th' },
      };
      metricsContainer.innerHTML = Object.entries(metrics).map(([k,v])=>{
        const percentage = v.toFixed(1);
        const colorClass = v >= 75 ? 'text-green-600' : v >= 50 ? 'text-yellow-600' : 'text-red-600';
        return `
          <div class="metric-card bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
            <div class="flex items-center justify-between mb-2">
              <div class="flex items-center">
                <i class="${labels[k].icon} text-primary mr-2"></i>
                <span class="font-medium">${labels[k].name}</span>
              </div>
              <span class="font-bold ${colorClass}">${percentage}%</span>
            </div>
            <div class="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2">
              <div class="bg-gradient-to-r from-primary to-purple-600 h-2 rounded-full transition-all duration-1000" style="width: ${v}%"></div>
            </div>
          </div>
        `;
      }).join('');

      // Visuals
      const visualComparison = document.getElementById('visualComparison');
      visualComparison.innerHTML = `
        <div class="comparison-images">
          <div class="image-preview">
            <img src="${images.ref}" alt="مرجعية">
            <div class="image-label">المرجعية</div>
          </div>
          <div class="image-preview">
            <img src="${images.sus}" alt="قيد الفحص">
            <div class="image-label">قيد الفحص (بعد التطبيع)</div>
          </div>
          <div class="image-preview">
            <img src="${images.heatmap}" alt="خريطة الفروقات">
            <div class="image-label">خريطة الفروقات (حرارية)</div>
          </div>
          <div class="image-preview">
            <img src="${images.susELA}" alt="ELA">
            <div class="image-label">ELA للصورة قيد الفحص</div>
          </div>
        </div>
        <div class="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-700">
          <h4 class="font-bold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
            <i class="fas fa-info-circle mr-2"></i>
            تفسير سريع
          </h4>
          <ul class="text-blue-700 dark:text-blue-300 text-sm space-y-1">
            <li>• المناطق الساخنة (صفراء/حمراء) في خريطة الفروقات تشير إلى اختلافات أعلى.</li>
            <li>• ELA يبرز مناطق ضغط JPEG غير المتجانس، الوميض غير الطبيعي قد يدل على قص/لصق.</li>
            <li>• اختلافات الإضاءة أو الدقة قد تُظهر فروقات غير متعلقة بالتزوير، لذا يُفضّل صوراً متقاربة الظروف.</li>
          </ul>
        </div>
      `;
      document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
    }
  </script>
</body>
</html>
